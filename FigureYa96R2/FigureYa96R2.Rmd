---
title: "FigureYa96R2"
author: "小丫画图出品"
date: "2019-5-26"
output: html_document
---
欢迎关注“小丫画图”公众号，同名知识星球等你加入

小丫微信: epigenomics  E-mail: figureya@126.com

作者：果子，欢迎关注“果子学生信”公众号

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

FigureYa92immune_gene只是1个基因跟免疫浸润的关系。我想要展示两个基因表达跟免疫浸润高/低的关系。

左右两侧纵坐标分别展示两个基因的表达量；横坐标按其中一个基因排序，两种颜色展示高/低免疫浸润，可以用FigureYa71ssGSEA热图中对高/低免疫浸润的结果作为输入。

![](example.png)

出自<https://www.nature.com/articles/s41467-018-06648-6>

## 应用场景

评价基因对免疫浸润的影响；

批量筛选出影响免疫浸润的候选基因；

同样适用于展示转录因子和靶基因表达调控的关系。

在“小丫画图”公众号回复“R2”，查看如何将这个图用在paper里。

## 输入文件的获得

如果你的数据已经整理成very_easy_input.csv的格式，就可以跳过这步，直接进入“开始画图”。

这里基于免疫细胞矩阵把样品分为两类，并把分类信息加到基因表达矩阵里。要求两个文件的样本名一致：

- ssGSEA_output.csv，免疫细胞矩阵，列是免疫细胞，行是样本，由FigureYa71ssGSEA产生。目的是给样品分类，可以换成其他临床信息、突变信息等等。
- easy_input_expr.csv，基因表达矩阵，列是样本，行是基因。行也可以是转录本，甚至是临床信息。

```{r}
#免疫细胞的数据
tcga_gsva <- read.csv("ssGSEA_output.csv",row.names = 1)
rownames(tcga_gsva) <- gsub("\\.","-",rownames(tcga_gsva))
tcga_gsva[1:3, 1:3]

tcga_expr <- data.table::fread("easy_input_expr.csv", data.table = F)
## 第一列转为行名
rownames(tcga_expr) <- tcga_expr[,1]
tcga_expr <- tcga_expr[,-1]
head(tcga_expr)[,1:4]
```

### 通过画热图聚类确定高、低免疫浸润的分组

```{r,fig.width=8, fig.height=8}
## 数据需要转置，使得样本成为列
data <- data.frame(t(tcga_gsva),check.names = F)
library(pheatmap)
pheatmap(data, #热图的数据
         cluster_rows = TRUE,#行聚类
         cluster_cols = TRUE,#列聚类，可以看出样本之间的区分度
         #annotation_col =annotation_col, #标注样本分类
         annotation_legend=TRUE, # 显示注释
         show_rownames = T,# 显示行名
         show_colnames = F,# 显示列名
         scale = "row", #以行来标准化，这个功能很不错
         color =colorRampPalette(c("blue", "white","red"))(100),#调色
         #filename = "heatmap_F.pdf",#是否保存
         cellwidth = 0.6, cellheight = 16,# 格子比例
         fontsize = 10)
```

从热图上看出，至少样本能分为两大类，接下来就是确定样本分类。

dist计算欧式距离，hclust层次聚类

```{r}
dd <- as.data.frame(scale(t(data))) 
dd_dist <- dist(dd, method = 'euclidean')
dd_hclust <- hclust(dd_dist, method = 'complete')
plot(dd_hclust, cex = 0.6, hang = -1)
```

切割成两类得到样本的属性

```{r}
grp <- cutree(dd_hclust, k = 2)
table(grp)
```

### 把分组信息加入到表达矩阵里

用表达量的样本来重新排列样本顺序，构建一个数据框。行是样本，列是基因，再加一类样本分类的数据，这就足够画图了。

```{r}
grp <- grp[colnames(tcga_expr)]
data <- data.frame(TCGA_id= colnames(tcga_expr),
                   immune_group=grp,
                   t(tcga_expr),stringsAsFactors = F)
data[1:10,1:10]

#保存到文件
#write.csv(data, "very_easy_input.csv", quote = F, row.names = F)
#这里只保存前3行，以供模仿格式时参考
write.csv(data[1:3,], "very_easy_input.csv", quote = F, row.names = F)
```

## 输入文件

带有样品分组信息的基因表达矩阵。

每行一个样品，第一列是样品分组信息，此处是两组，还可以是更多组，之后每列一个基因。

```{r}
#data <- read.csv("very_easy_input.csv")
data[1:3, 1:6]
```

## 开始画图

用ggplot2画图，基本的逻辑如下：

- 横坐标是样本，按照第一个基因的表达量来排序
- 纵坐标两个基因的表达量，分别用两个坐标轴来表示
- 纵坐标的坐标轴颜色用theme来调整
- 底部的竖线用geom_rug来实现
- 文字使用geom_textl来打印，打印的位置固定在纵坐标的下1/8处
- 实现文字的相对位置固定，需要先画出一部分图，保存为ggplot对象，再在对象中选取

### 直接画图

```{r,fig.width=8, fig.height=4}
library(ggplot2)
library(dplyr)
p <- data %>% 
  arrange(SRGN) %>% 
  ggplot(aes(forcats::fct_reorder(TCGA_id,SRGN),log2(SRGN)))+ #左侧y轴的基因
  geom_point(color="red",size=1) +
  geom_point(aes(TCGA_id,log2(BCL2A1)),color="blue",size=1)+ #右侧y轴的基因
  scale_y_continuous(sec.axis = sec_axis(~ ., name = "log2(BCL2A1)"))+
  geom_rug(aes(x=TCGA_id,y = NULL,color=factor(immune_group)))+
  scale_color_manual(values =c("springgreen3","red"))+
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.line.x.bottom = element_line(colour = "white"),
        axis.line.y.left = element_line(colour = "black"),
        axis.line.y.right = element_line(colour = "black"),
        legend.position='none',
        axis.text.y.right = element_text(color=c("blue")),
        axis.title.y.right = element_text(color=c("blue")),
        axis.text.y.left = element_text(color=c("red")),
        axis.title.y.left = element_text(color=c("red")))
ypos <- (quantile(layer_scales(p)$y$range$range)[2]+quantile(layer_scales(p)$y$range$range)[1])/2
p +   geom_text(aes(x=nrow(data)/3,y=ypos,label="Red-high immune tissues"),col ="red",size = 5)+
  geom_text(aes(x=nrow(data)/3*2,y=ypos,label="Green-low immune tissues"),col ="springgreen3",size = 5)
```

### 或者写成一个作图函数，方便调用

```{r}
dgplot <- function(x,y){
  dd <- data[,c("TCGA_id","immune_group",x,y)]
  names(dd)[3:4] <- c("geneA","geneB")
  require(dplyr)
  require(ggplot2)
  p <- dd %>% 
    arrange(geneA) %>% 
    ggplot(aes(forcats::fct_reorder(TCGA_id,geneA),log2(geneA)))+
    geom_point(color="red",size=1) +
    geom_point(aes(TCGA_id,log2(geneB)),color="blue",size=1)+
    scale_y_continuous(sec.axis = sec_axis(~ ., name = paste0("log2(",y,")")))+
    geom_rug(aes(x=TCGA_id,y = NULL,color=factor(immune_group)))+
    scale_color_manual(values =c("springgreen3","red"))+
    theme(axis.title.x=element_blank(),
          axis.text.x=element_blank(),
          axis.ticks.x=element_blank(),
          axis.line.x.bottom = element_line(colour = "white"),
          axis.line.y.left = element_line(colour = "black"),
          axis.line.y.right = element_line(colour = "black"),
          legend.position='none',
          axis.text.y.right = element_text(color=c("blue")),
          axis.title.y.right = element_text(color=c("blue")),
          axis.text.y.left = element_text(color=c("red")),
          axis.title.y.left = element_text(color=c("red")))+
    labs(y=paste0("log2(",x,")"))
  ## 获取y轴的下1/8坐标，layer_scales(p)$y$range$range这一句是获取y轴的范围
  ypos <- mean(quantile(layer_scales(p)$y$range$range)[1:2])
  p <- p + geom_text(aes(x=nrow(data)/3,y=ypos,label="Red-high immune tissues"),col ="red",size = 5)+
    geom_text(aes(x=nrow(data)/3*2,y=ypos,label="Green-low immune tissues"),col ="springgreen3",size = 5)
  print(p)
}
```

只需这一行就能选择基因画图

```{r,fig.width=8, fig.height=4}
dgplot("SRGN","AP1M2") #选这两个基因，它俩负相关
#保存到pdf文件
ggsave("SRGN_AP1M2.pdf", width = 8, height = 4)
```

```{r,fig.width=8, fig.height=4}
dgplot("SRGN","BCL2A1") #再试两个，它俩正相关
```

```{r,fig.width=8, fig.height=4}
dgplot("PERM1","ISG15") #随便再选两个，没啥关系
```

## 批量筛选高度正/负相关的基因

上面用三对基因画出的三个图，分别展示了两个基因之间正相关、负相关和不相关的规律，同时还能看出基因表达量跟免疫浸润之间的关系。

而最后一个图，横坐标比较乱，说明PERM1的表达量和免疫浸润关系不大，而且PERM1和ISG15这两个基因也没有相关性。

> 怎样画出像前两对基因那样的效果呢？

这就需要进行批量筛选了。

如果要想画出同时跟免疫相关、两个基因又相关的图，需要经过两次计算：

1. 选出跟免疫浸润相关的基因
2. 选出给定基因的高相关基因

### 选出跟免疫浸润相关的基因

目前跟免疫直接相关的数据，我们拥有的是每个样本中的免疫细胞数据。要获得基因的数据，需要批量计算跟免疫细胞相关的基因。

计算相关性之前，保证免疫矩阵和表达量矩阵两者的样本排序一致。

```{r}
tcga_gsva <- tcga_gsva[colnames(tcga_expr),]
```

写一个函数，计算任意表达量数据中的基因与其他因素的相关性。

其他因素可以是两外一个基因，也可以是任何个数一致的变量。

```{r}
my_cor <- function(x,y){
  dd <- cor.test(as.numeric(tcga_expr[x,]),y,type="spearman")
  c(cor=dd$estimate,p.value=dd$p.value)
}
```

举个例子，可以用这个函数计算SRGN跟免疫细胞Neutrophils的相关性。

```{r}
index <- "Neutrophils"
y <- as.numeric(tcga_gsva[,index])
my_cor("SRGN",y)
```

### 1. 批量计算基因与特定免疫细胞的相关性

免疫细胞以Neutrophils为例，批量计算所有基因的表达谱跟免疫细胞Neutrophils的相关性，进而筛选到跟免疫细胞Neutrophils相关性高的基因。

```{r,message=FALSE, warning=FALSE}
library(future.apply)
plan(multiprocess)
index <- "Neutrophils"
y <- as.numeric(tcga_gsva[,index])
system.time(data <- future_lapply(rownames(tcga_expr),my_cor,y))

result1 <- data.frame(genes=rownames(tcga_expr),
                     do.call(rbind,data),stringsAsFactors = F)
head(result1)
#保存到文件
write.csv(result1, "output_corr.csv", quote = F, row.names = F)
```

筛选出相关性最高的Top10

```{r}
library(dplyr)
result1 %>% 
  filter(p.value < 0.05) %>% 
  arrange(desc(cor.cor)) %>% 
  head()
```

下面就用排名第一的SRGN作为第一个基因，寻找跟它表达量高度相关的第二个基因。

### 2. 批量计算SRGN与其他基因的相关性

```{r,message=FALSE, warning=FALSE}
index <- "SRGN"
y <- as.numeric(tcga_expr[index,])
system.time(data <- future_lapply(rownames(tcga_expr),my_cor,y))
result2 <- data.frame(genes=rownames(tcga_expr),
                     do.call(rbind,data),stringsAsFactors = F)
```

筛选正相关的Top10

```{r}
library(dplyr)
result2 %>% 
  filter(p.value < 0.05) %>% 
  arrange(desc(cor.cor)) %>% 
  head()
```

排名第二个的BCL2A1就是正相关例图中的那个基因

筛选负相关的Top10

```{r}
library(dplyr)
result2 %>% 
  filter(p.value< 0.05) %>% 
  arrange(cor.cor) %>% 
  head()
```

排名第一个的AP1M2基因就是负相关例图中的那个基因。

选好了基因，就可以返回“开始画图”，画美图了。

```{r}
sessionInfo()
```