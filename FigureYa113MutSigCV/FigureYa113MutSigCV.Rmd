---
title: "FigureYa113MutSigCV"
author: "小丫画图出品"
date: "2019-7-14"
output: html_document
---
欢迎关注“小丫画图”公众号，同名知识星球等你加入

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：Research Center of Biostatistics and Computational Pharmacy, China Pharmaceutical University

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

用MutSigCV推断SMG（significantly mutated gene），画出文章里的图。

MutSigCV是用matlab写成的，带我顺利用上它。

![](example.png)

出自<https://www.frontiersin.org/articles/10.3389/fonc.2019.00488/full>

# 应用场景

画基因突变瀑布图时，展示哪几个基因呢？可以展示显著突变基因。看例文描述：We used MutSigCV_v1.41 (20) (www.broadinstitute.org) to infer significant cancer mutated genes (q < 0.05) across the two classes currently identified with default parameters.

MutSigCV是用来推断SMG（significantly mutated gene）的，会综合考虑基因长度，以及沉默突变和非沉默突变的频率，因此如果没有沉默突变（silent mutation），或沉默突变过少（算法内有固定阈值），这个算法是无法运行的。

**注意：**若使用MutSigCV，请引用：
Lawrence MS, Stojanov P, Polak P, Kryukov GV, Cibulskis K, Sivachenko A, Carter SL, Stewart C, Mermel CH, Roberts SA (2013) Mutational heterogeneity in cancer and the search for new cancer-associated genes. Nature 499(7457): 214

如果只想直接从TCGA下载MAF文件画图，可直接使用FigureYa18oncoplot，还可以进一步用FigureYa42oncoprint自己定制瀑布图。

# 环境设置

先在R里准备MutSigCV所需的输入数据，然后用MutSigCV推断SMG，最后在R里用MutSigCV的输出文件画瀑布图。

（其实Matlab的使用方式很傻瓜，比R更容易，更像Excel）

## 安装MutSigCV

第一步：安装Matlab。目前MutSigCV的源码是用Matlab编写的，可前往Matlab网站注册，下载30天试用版：<https://ww2.mathworks.cn/campaigns/products/trials.highResolutionDisplay.html?prodcode=ML>。

第二步：把`MutSigCV.m`文件拷贝到当前文件夹就可以使用了。

## 安装并加载画图所需的R包

```{r}
#使用国内镜像安装所需的R包
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
#BiocManager::install("ComplexHeatmap")

#加载R包
library(tidyverse)
library(magrittr)
library(readxl)
library(stringr)
library(forcats)
library(ComplexHeatmap)
library(RColorBrewer)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

# 输入文件

easy_input_meta.local mutation.full.txt，MAF文件，用于推断SVG。从TCGA下载MAF文件的方法可参考FigureYa19Lollipop。

meta.mut.rda和local.mut.rda，用于画图时展示两组，非必需。里面分别保存了两组样品名称（字符串）。此处只是为了重现原图，实际使用时请选用自己不同亚型的样本。

另外，在后面的“使用MutSigCV推断SMG”的“参数设置”部分需要下载默认文件。

```{r}
# 读取MAF文件
meta.maf <- as.data.frame(read_tsv("easy_input_meta.local mutation.full.txt", comment = "#"))
head(meta.maf)

# 读取两组样品名，仅在画图时需要它
meta.mut <- read.table("easy_input_meta.mut.txt")[,1]
local.mut <- read.table("easy_input_local.mut.txt")[,1]
```

# 输入文件预处理

把MAF文件整理成MutSigCV所需的输入文件的格式，生成文件：meta.local mutation.full_for_MutSig_input.txt

阅读MutSigCV教程，了解数据格式要求，就能理解下面的预处理过程了

```{r}
# 确认Tumor_Seq_Allele1和Tumor_Seq_Allele2是否一致（见MutSigCV教程）
if(!identical(meta.maf$Tumor_Seq_Allele1,meta.maf$Tumor_Seq_Allele2)) {

  cat("Tumor_Seq_Allele1 and Tumor_Seq_Allele2 should be the same!\n")
  cat("Processing is running...\n")
  meta.maf$Tumor_Seq_Allele1 <- meta.maf$Tumor_Seq_Allele2
  if(all(meta.maf$Tumor_Seq_Allele1 == meta.maf$Tumor_Seq_Allele2) &  !all(meta.maf$Tumor_Seq_Allele1 == meta.maf$Reference_Allele)) {
    cat("Your data is free to go now!\n")
  }
}

# 选择MutSigCV算法需要的列，输出到当前文件夹
outTable <- meta.maf %>%
  select(Hugo_Symbol,Tumor_Sample_Barcode,Variant_Classification,Reference_Allele,Tumor_Seq_Allele1,Tumor_Seq_Allele2)
write.table(outTable,"meta.local mutation.full_for_MutSig_input.txt",sep = "\t",row.names = F,quote = F)
```

# 使用MutSigCV推断SMG

这一步要用到Matlab，会生成meta.local mutation.full_MutSig_output.sig_genes.txt文件，用于下一步画图。

也可以在GenePattern云服务器上运行，不想使用Matlab的小伙伴就自行探究在线模式吧。

## 参数设置

MutSigCV算法，这里采用：

- 默认参数：hg19注释文件, chr_files_hg19文件夹
- 默认的突变字典文件：mutation_type_dictionary_file.txt
- 默认的coverage文件：gene.covariates.txt和exome_full192.coverage.txt

以上默认文件的源文件下载自<https://software.broadinstitute.org/cancer/cga/mutsig_download>，注册后就能下载。我已经下载好，微云地址：<https://share.weiyun.com/5MyC44s>，下载后全部解压到当前文件夹。

若对该算法非常熟悉，或者有其他个性化需求，可以自定义这些文件，技术细节请参考：<http://software.broadinstitute.org/cancer/software/genepattern/modules/docs/MutSigCV>

## 运行MutSigCV

前面已经攒齐了输入文件，都保存在当前文件夹里。

现在，在Matlab的Current Folder里选择进入当前文件夹，然后把下面这行代码复制粘贴到Matlab的Command Window，敲回车，就开始运行啦！

```matlab
MutSigCV('meta.local mutation.full_for_MutSig_input.txt','exome_full192.coverage.txt','gene.covariates.txt','meta.local mutation.full_MutSig_output','mutation_type_dictionary_file.txt','chr_files_hg19')
```

![](matlab.png)

数据格式以及输入命令的参数意义：

- 第一个参数：maf文件（请注意我使用的maf文件的格式，抬头最好完全一致，且Variant_Classification中的突变名称也必须匹配突变字典中的名字，举个简单的例子，沉默突变必须叫Silent，不能叫silent，不能叫silence，也不能叫synonymous）；此外，Reference_Allele为参考碱基，Tumor_Seq_Allele1为突变碱基，且必须与Allele2完全一致，而在有些MAF calling的方法里，这两列是不一致的，请仔细确认并且在R代码的预处理部分根据实际情况修改！！！
- 第二个参数以及第三个参数默认，第四个参数为输出文件的前缀，后两个参数也默认，一个是数据字典，一个是使用的注释文件。
- 我将网页上比较关键的一页**How to run MutSigCV**转成了pdf，供大家查看详情。

程序运行结束后，无论是成功还是失败，都会再次出现fx>>。可以看到程序提示显著突变的结果被保存到sig_genes后缀的txt文件：Wrote results to meta.local mutation.full_MutSig_output.sig_genes.txt

随后在文件夹下会生成4个文件：

- meta.local mutation.full_MutSig_output.sig_genes.txt
- meta.local mutation.full_MutSig_output.categs.txt
- meta.local mutation.full_MutSig_output.coverage.txt
- meta.local mutation.full_MutSig_output.mutations.txt

这四个文件中后缀为sig_genes是显著突变基因，打开根据qvalue或者pvalue筛选即可，一般qvalue < 0.05，类似调整的p值：

# 开始画图

提取显著突变基因SMGs，用q < 0.05筛选

```{r}
mutsigcv <- read.table("meta.local mutation.full_MutSig_output.sig_genes.txt",sep = "\t",row.names = 1,header = T,stringsAsFactors = F)
mutsigcv <- rownames(mutsigcv[mutsigcv$q < 0.05,]) #此处用q < 0.05筛选
# 查看一下筛到了哪些显著突变基因
mutsigcv
```

画图

```{r, warning=FALSE}
### 设置颜色 ###
jco <- c("#2874C5","#EABF00")
lightgrey <- "#dcddde"

mutsig.maf <- as.data.frame(meta.maf[which(meta.maf$Tumor_Sample_Barcode %in% c(meta.mut,local.mut)),c("Tumor_Sample_Barcode","Hugo_Symbol","Variant_Classification")]) # 提取这些突变所对应的sub-MAF数据
onco.input <- reshape(data = mutsig.maf,
                      idvar = "Hugo_Symbol",
                      timevar = "Tumor_Sample_Barcode",
                      direction = "wide")

colnames(onco.input) <- gsub("Variant_Classification.","",colnames(onco.input))
onco.input[is.na(onco.input)] <- "" # NA值填补空
rownames(onco.input) <- onco.input$Hugo_Symbol

# 改名以防出现符号bug
onco.input[onco.input == "5'Flank"] <- "Flank5"
onco.input[onco.input == "3'Flank"] <- "Flank3"
onco.input[onco.input == "5'UTR"] <- "UTR5"
onco.input[onco.input == "3'UTR"] <- "UTR3"
onco.input <- onco.input[,-1] # 去掉第一列Hugo_Symbol

mygene <- onco.input[mutsigcv,c(meta.mut,local.mut)] # 按照转移和未转移排序，并只选择SMGs

# 计算有多少个突变类型
type <- c()
for (i in 1:nrow(mygene)) {
  tmp <- as.character(mygene[i,])
  type <- unique(c(type,tmp))
}
type # 根据type的类型调整下面的颜色

# 设置调色板（个人喜好）
mycol <- colorRampPalette(brewer.pal(11,'Spectral'))(12)[12:1]
alter_fun = list(
  background = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = lightgrey, col = NA))
  },
  Missense_Mutation = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[1], col = NA)) 
  },
  Nonsense_Mutation = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[2], col = NA)) 
  },
  Frame_Shift_Del = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[3], col = NA)) 
  },
  Frame_Shift_Ins = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[4], col = NA)) 
  },
  UTR5 = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[5], col = NA)) 
  },
  Splice_Site = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[6], col = NA)) 
  },
  Silent = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[7], col = NA)) 
  },
  UTR3 = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[8], col = NA)) 
  },
  In_Frame_Del = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[9], col = NA))
  },
  Flank5 = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[10], col = NA))
  },
  Intron = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[11], col = NA)) 
  },
  In_Frame_Ins = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[12], col = NA)) 
  }
)

col = c("Missense_Mutation" = mycol[1], 
        "Nonsense_Mutation" = mycol[2], 
        "Frame_Shift_Del" = mycol[3], 
        "Frame_Shift_Ins" = mycol[4], 
        "UTR5" = mycol[5],
        "Splice_Site" = mycol[6],
        "Silent" = mycol[7],
        "UTR3" = mycol[8],
        "In_Frame_Del" = mycol[9],
        "Flank5" = mycol[10],
        "Intron" = mycol[11],
        "In_Frame_Ins" = mycol[12])

# 注释文件
my_annotation = HeatmapAnnotation(df = data.frame(MetaStatus=rep(c("Meta","Local"),c(49,144))),
                                  col = list(MetaStatus=c("Meta"=jco[2],"Local"=jco[1])))

# 绘图
pdf("oncoprint_mutsigcv_detailed_variationtype.pdf",width = 10,height = 4)
oncoPrint(mygene, alter_fun = alter_fun, col = col,
          show_pct = T, #show pct in left
          column_title = "",
          bottom_annotation = my_annotation,
          show_heatmap_legend=T,
          column_title_gp = gpar(fontsize = 8),
          row_names_gp = gpar(fontsize = 7),
          column_names_gp = gpar(fontsize = 6)) 
dev.off()
```

![](oncoprint_mutsigcv_detailed_variationtype.pdf)

# 附：

作者使用的是Matlab R2017a版本，可以自行百度下载破解，也可采用如下百度网盘下载，附破解方法，见文件夹MATLAB R2017a安装方法.pdf。
链接：https://pan.baidu.com/s/1koGMNmEALL1FmDakNwHa9A 
提取码：3et5

小丫使用的是Matlab R2019a的30天试用版本，已运行成功。

```{r}
sessionInfo()
```