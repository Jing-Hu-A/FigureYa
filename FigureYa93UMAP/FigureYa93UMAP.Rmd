---
title: "FigureYa93UMAP"
author: "小丫画图出品"
date: "2019-5-19"
output: html_document
---
欢迎关注“小丫画图”公众号，同名知识星球等你加入

小丫微信: epigenomics  E-mail: figureya@126.com

作者：徐洲更，欢迎关注他的简书[「思维发散」R语言分组计算的N种方法
](https://www.jianshu.com/p/3e20af42e9f8)

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

文章里用的是t-SNE，我想用UMAP画这样的图。

t-SNE可参考FigureYa27t-SNE

![](https://ars.els-cdn.com/content/image/1-s2.0-S1534580719301455-fx1.jpg)

出自<https://www.sciencedirect.com/science/article/pii/S1534580719301455?via%3Dihub>

## 应用场景

UMAP，三大主流的降纬方法之一。UMAP相对于t-SNE的优势在于能够保存局部结构信息，也就是空间距离比较近的细胞类群在结果展示的时候也会比较近。这里用到的Seurat的`RunUMAP`其实是调用Python的UMAP进行处理。

## 环境设置

先查看install_UMAP.md，安装anaconda和UMAP和添加环境变量。

> Windows系统根据提供的视频“Windows10-UMAP安装.mov”进行软件安装和检查

Mac系统这样添加环境变量：

```r
Sys.getenv("PATH") #检查/Anaconda/bin 是否在环境中
Sys.getenv("PATH"="/anaconda3/bin/") #如果不在的话，需要将其加入环境变量中
Sys.getenv("PATH") #再次检查
```

使用国内镜像安装包

```r
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
install.packages("Seurat")
```

加载包

```{r}
library(Seurat)
library(dplyr)
library(data.table)
library(cowplot)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

## 数据读取

Seurat可以直接读取以下两种类型：

1. CellRanger分析结果
2. 表达量矩阵

后文将以表达量矩阵作为输入为例。

### 读入表达量矩阵CSV/TXT文件

如果是表达量矩阵，是用`data.table::fread()`进行读取。本次的案例数据提供的就是csv文件.

```{r}
df <- fread("GSE123818_Root_single_cell_wt_datamatrix.csv.gz",
                           data.table = FALSE)
expression_matrix <- as.matrix(df[,-1])
row.names(expression_matrix) <- df$V1
rm(df)
```

数据来源: <https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE123818>

### 附：CellRanger结果的读取

对于CellRanger分析结果，Seurat有专门的函数`Read10X()`进行读取, 以Seurat下载PMBC为例, 将filtered_gene_bc_matrices.zip解压缩得到 filtered_gene_bc_matrices

```r
data_dir <- 'filtered_gene_bc_matrices/hg19/'
list.files(data_dir)
expression_matrix <- Read10X(data.dir = data_dir)
```

无论是那种来源, 最终得到的expreesion_matrix都是表达矩阵, 行是基因名, 列是细胞名

```{r}
expression_matrix[1:2,1:2]
```

## 构建Seurat对象

使用`CreateSeuratObject`从表达量矩阵中构建`SeuratObject`

```{r}
seurat_obj <- CreateSeuratObject(count = expression_matrix,
                                 min.cells = 0,
                                 min.features = 0)
seurat_obj
```

这里的结果是4727 samples, 27629 features

参数解释： 

- count: 原始的count或者TPM
- min.cells: 只保留至少在N个细胞中出现的基因或蛋白
- min.features: 保留至少有N个检测基因或蛋白的细胞

## 数据预处理

### 过滤死细胞

通常是看线粒体基因和基因组基因的比例来检查。

这里的pattern指的是线粒体命名的规则，示例数据是拟南芥。

如果是人类，则是`pattern = "^MT-"`

```{r}
seurat_obj[['percent.mt']] <- PercentageFeatureSet(seurat_obj, pattern = "ATMG")
```

之后用小提琴图可视化基因表达量的分布

```{r}
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

这里的过滤标准根据实际展示结果来决定。比如说本次的mFeature_RNA大部分都集中在1000以下, 线粒体比例都是在0.2以下，那么过滤代码就是

```{r}
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA < 10000 & percent.mt < 0.2)
seurat_obj
```

过滤之后, 细胞剩下4568个。

### 数据标准化

细胞过滤后的下一步是标准化，通常用`LogNormalize`即可

```{r}
seurat_obj <- NormalizeData(seurat_obj,
                            normalization.method = "LogNormalize", 
                            scale.factor = 10000)
```

参数说明:

- normalization.method: 标准化方法, 可选有LogNormalize, CLR, RC
- scale.factor: 一般10000即可

### 识别HVG(highly variable features)

为了降低运算量，我们通常使用哪些在样本间存在变化的基因(HVG)用于下游分析，而非全部的基因集

这一步用到的函数`FindVariableFeatures`

```{r}
seurat_obj <- FindVariableFeatures(seurat_obj, 
                                   selection.method = "vst", 
                                   nfeatures = 2000,
                                   num.bin = 20)
```

参数解释:

- selection.method: 筛选方法, 
  - vst
  - mean.var.plot
  - dispersion
- nfeatures: 最终选择前N个基因, 配合vst和dispersion使用
- num.bin：样本分组,默认20, 不需要修改

```{r}
# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(seurat_obj), 10)

# plot variable features with and without labels
plot1 <- VariableFeaturePlot(seurat_obj)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
plot2
```

### 数据缩放(scale)

在PCA之前需要使用线性转换(scaling)对数据进行预处理，其目的是

- 将每个基因的表达量进行偏移，使其均值在细胞间为0
- 对每个基因的表达量进行缩放，使其在细胞间的方差(variance)为1

```{r}
all.genes <- rownames(seurat_obj)
seurat_obj <- ScaleData(seurat_obj, features = all.genes)
```

如果处理速度太慢，可以不加任何参数运行，默认会用HVGF。


### 线性降维(PCA)

对缩放后的结果进行PCA线性降维

```{r}
seurat_obj <- RunPCA(seurat_obj, 
                     features = NULL,
                     npcs = 100,
                     ndims.print = 1:5,
                     nfeatures.print = 5)
```

参数说明:

- features: 用于计算PCA的基因，默认NULL表示选择HVG
- npcs: 总的PC数，默认50
- ndims.print: 输出前N个PC
- nfeatures.print: 输出每个PC的前N个基因

用滚石图确定聚类和UMAP用的PC数

```{r}
ElbowPlot(seurat_obj, ndims = 100)
```

我们选择拐点处，趋于平缓的PC。这里感觉**50**可能就够了。

选择PC数是一个不确定的过程，因此有以下几种方法可以考虑：

1. 根据每个PC里的基因，根据背景知识确定哪些PC比较重要
2. 使用统计学的方法，也就是后面的`JackStraw`, 找p值小于0.05(0.01)的PC
3. 先用滚石图确定，然后分析结果，根据分析结果调整PC数

如果计算能力够，可以用下面的代码进行分析

```r
seurat_obj <- JackStraw(seurat_obj, num.replicate = 100)
seurat_obj <- ScoreJackStraw(seurat_obj, dims = 1:100)
JackStrawPlot(seurat_obj, dims = 1:100)
```

### 细胞聚类

> 这部分内容并非这次UMAP的重点，但是UMAP展示聚类时需要用到

> 聚类分析是一个非常复杂的过程，并非这个教程所能说清，因此不是本教程的重点，只简单演示代码

```{r}
seurat_obj <- FindNeighbors(seurat_obj, dims = 1:50)
seurat_obj <- FindClusters(seurat_obj, resolution = 0.8)
```

最终得到了18个分群，比文章的分群数目多。

### 定义细胞类群

> 为了体现UMAP的优势，我根据文章给定的标记基因(附件TableS1)定义了这次分析的分群

通常使用DEG来鉴定不同分群的marker

```{r}
markers <- FindAllMarkers(seurat_obj, 
               test.use = "bimod",
               logfc.threshold = 0.25)
```

差异分析完成之后, 在挑选marker时, 尽可能保证基因在聚类中表达细胞数多, 除此之外的细胞数少, 然后可以按照Fold Change进行排序, 选择每个cluster前10个

```{r}
library(dplyr)
marker2 <- markers[ markers$pct.1 > 0.1 & markers$pct.2 < 0.1 ,]

marker3 <- marker2 %>% 
  group_by(cluster) %>% 
  top_n(n=10, wt=avg_logFC)

write.table(marker3, "markers.csv", sep=",", row.names = F, col.names = T)
```

打开csv文件，然后根据附件"devcel_4493_mmc3.xlsm"里的标记信息，命名我们的cluster

```{r}
new.cluster.ids <- c("0"="Mature",
                     "1"="Meristem",
                     "2"="Meristem/QC/Colummela",
                     "3"="Trichoblast",
                     "4"="Meristem",
                     "5"="Unknown",
                     "6"="Atrichoblast",
                     "7"="Meristem",
                     "8"="Stele",
                     "9"="Mature",
                     "10"="Cortex/Endodermis",
                     "11"="Atrichoblast",
                     "12"="QC/Colummela",
                     "13"="Xylem",
                     "14"="Mature",
                     "15"="Endodermis",
                     "16"="Trichoblast",
                     "17"="Mature"
                    )
names(new.cluster.ids) <- levels(seurat_obj)
seurat_obj <- RenameIdents(seurat_obj, new.cluster.ids)
```

### UMAP非降维分析

UMAP相对于t-SNE的优势在于能够保存局部结构信息，也就是空间距离比较近的细胞类群在结果展示的时候也会比较近。

Seurat的`RunUMAP`其实是调用Python的UMAP进行处理，UMAP的GitHub地址为<https://github.com/lmcinnes/umap>

```{r}
# 版本1
seurat_obj <- RunUMAP(seurat_obj, dims = 1:50)
# 调参版本2
seurat_obj2 <- RunUMAP(seurat_obj, 
                       dims = 1:50,
                       n.neighbors = 15,
                       min.dist = 0.1,
                       metric = "correlation")
```

UMAP有很多参数可供调整，但是最重要的是下面几个：

- dims: 使用维度数, 即之前选择的PC数
- n_neighbors: 每个细胞的邻近细胞数。默认是30, 值越大会导致局部细节信息缺失, 但是全局结构更好. 参数应该在5-50之间，
- min_dist: 值越大, 点的在图上分布越均匀, 值越小, 局部结构更好. 默认是0.3, 建议范围在0.001-0.5
- metric: 计算距离聚类的算法, 推荐看<https://umap-learn.readthedocs.io/en/latest/parameters.html#metric>


### UMAP展示聚类结果

用DimPlot进行可视化展示，默认用聚类进行上色, 标签输出在旁边，用自定义颜色

```{r}
# 默认参数的UMAP#
p1 <- DimPlot(seurat_obj, 
        reduction = "umap",
        pt.size = 1,
        label = FALSE)

# 调整参数的UMAP
p2 <- DimPlot(seurat_obj2, 
        reduction = "umap",
        pt.size = 1,
        label = FALSE)
```

参数说明：

- cols: 使用自己定义的颜色
- pt.size: 图中点的大小
- label: 是否将标签输出在细胞类群上
- repel: 如果标签有可能重叠，设置为TRUE

结果展示:

默认参数UMAP结果

```{r}
print(p1)
```

调整参数后的UMAP结果

```{r}
print(p2)
```

将两个图合并比较

```{r}
p12 <- cowplot::plot_grid(p1, p2, ncol = 1)
print(p12)
```


默认颜色不是特别的好看，我们需要给聚类自定义颜色

第一步: 先看看有多少个levels

```{r}
levels(seurat_obj)
```

第二步: 对每个level定义颜色 (颜色建议多看看单细胞的文章, 然后保存他们的颜色)

```{r}
# 命名规则
# "聚类"="颜色"
mycols <- c("Mature"= "#d7301f",
            "Meristem" = "#31a354",
            "Meristem/QC/Colummela" = "#ffeda0",
            "Trichoblast/Trichoblast" = "#b4e28b" ,
            "Atrichoblast" = "#1f78b4",
            "Stele"  = "#984ea3", 
            "Cortex/Endodermis" = "#006d2c",
            "QC/Colummela"  = "#db4622",
            "Xylem" ="#68c2cb",
             "Endodermis"  = "#0e8cf8",
             "Trichoblast" = "#04889d",
            "Unknown" = "#b4b4b5"
            )

```

调整之后的颜色如下

```{r}
p3 <- DimPlot(seurat_obj, 
        reduction = "umap",
        pt.size = 0.5,
        label = TRUE,
        cols =  mycols)
print(p3)
```

如果不想要右边的legend

```{r}
p4 <- p3 + NoLegend()
print(p4)
```

保存结果: 调整width和height改变PDF的长宽比

```{r}
pdf("UMAP_cluster.pdf", width = 8,height = 4)
print(p1)
print(p2)
print(p12)
print(p3)
print(p4)
dev.off()
```

### UMAP展示基因表达量

可以在UMAP上展示部分基因的分布

```{r}
fp <- FeaturePlot(seurat_obj, 
            features = c("AT4G34970","AT2G04025","AT1G13620"),
            cols = c("lightgrey", "#e41a1c"),
            pt.size = 0.5,
            label = FALSE,
            label.size = 4,
        reduction = "umap")
print(fp)
```

参数说明:

- features: 要展示的基因
- cols: 背景色和高亮色
- pt.size: 点的大小
- label: 是否在图中展示细胞的来源信息, 保持默认FALSE即可
- label.size: 标签字体大小

保存结果

```{r}
pdf("UMAP_gene_dist.pdf", width = 8,height = 4)
print(fp)
dev.off()
```

```{r}
sessionInfo()
```