---
title: "FigureYa127HeatmapPie"
author: "小丫画图出品"
date: "2019-8-5"
output: html_document
---
欢迎关注“小丫画图”公众号，同名知识星球等你加入

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：Research Center of Biostatistics and Computational Pharmacy, China Pharmaceutical University

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

绘制相关性热图并添加相关系数扇形图，使用TCGA GBM数据，原图复现。

![](example.png)

出自<https://www.tandfonline.com/doi/full/10.1080/2162402X.2017.1328339>

Figure 4. TIM-3-related T cell immunity and inflammatory activities in glioma. (A, B) The relationship between TIM-3 and T cell immunity in CGGA and TCGA data set.

## 应用场景

左侧是通路的表达矩阵（用gsva算出来的）热图。其实单画这个图，展示通路的表达变化，就可以放进文章里了。还可以参考FigureYa61GSVA的展示方式。

右侧用饼图展示各个通路跟某一个基因（例文用的是TIM-3）的相关性，若正相关则顺时针填充扇形图（红色），若负相关则逆时针填充扇形图（绿色）

## 环境设置

使用国内镜像安装包

```{r}
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
```

加载包

```{r}
library(clusterProfiler)
library(org.Hs.eg.db)
library(GSVA)
library(biomaRt)
library(GO.db)
library(pheatmap)
library(RColorBrewer)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```


## 输入文件

easy_input_expr.csv，TCGA-GBM.htseq_fpkm，基因表达谱。跟FigureYa126CorrelationHeatmap用的是同一个文件。从XENA下载得到，值为log2（FPKM+1），为方便传输，小数点后保留2位。需要把基因名换成gene symbol。

easy_input_GO.txt，感兴趣的通路的GO ID。

```{r}
### 读取GMB表达谱 ###
expr <- read.csv("easy_input_expr.csv", header = T, row.names = 1, stringsAsFactors = F, check.names = F)
rownames(expr) <- sapply(strsplit(rownames(expr),".",fixed = T),"[",1) # 取.号前的字符
colnames(expr) <- substr(colnames(expr),1,15)

# 利用bitr将entrez id 转为 gene symbol name
ensembl2gs <- bitr(rownames(expr),fromType = "ENSEMBL",toType = "SYMBOL",OrgDb = org.Hs.eg.db)
ensembl2gs <- ensembl2gs[!duplicated(ensembl2gs$SYMBOL),]

# 根据TCGA样品名的命名规律，提取出肿瘤样本
tum.sam <- colnames(expr)[which(substr(colnames(expr),14,15) == "01")]

# 生成新的表达谱
expr2 <- expr[ensembl2gs$ENSEMBL,tum.sam]
rownames(expr2) <- ensembl2gs$SYMBOL

# 根据TIM-3表达排序样本（TIM-3即为HAVCR2）
sam.order <- sort(expr2["HAVCR2",],decreasing = F)

### 读取感兴趣的通路
gosets <- read.table("easy_input_GO.txt")
gosets <- gosets$V1
```

## 对感兴趣GO通路做GSVA，从而获得通路的表达矩阵，并计算相关系数

```{r}
ensembl = useMart("ensembl",dataset="hsapiens_gene_ensembl") 

# 循环提取特定GO TERM内的基因生成签名列表
go.list <- list()
for (i in gosets) {
  gene.data <- getBM(attributes=c('hgnc_symbol'),
                     filters = 'go', 
                     values = i, 
                     mart = ensembl,
                     uniqueRows = T)
  if(i == "GO:0002852") { # 似乎查不到这个ID，在AmiGO2上找到一个基因：http://amigo.geneontology.org/amigo/term/GO:0002852
    go.list[[i]] <- "MUC4"
  } else {
    go.list[[i]] <- gene.data[,1]
  }
}

# 如果想知道这些GO ID对应的term，就运行下面三行
goterms <- Term(GOTERM)
goterms <- goterms[names(goterms) %in% gosets]
goterms

# GSVA富集分析
enrich.go <- gsva(expr = as.matrix(expr2[,names(sam.order)]), # 因为数据本身是对数转化的，所以这里不再取对数
                  gset.idx.list = go.list,
                  method = "gsva")

# 计算各个通路跟TIM-3基因的相关性
cor.res <- apply(enrich.go, 1, function(x) {return(cor.test(x,as.numeric(sam.order),method = "spearman"))}) # 根据例文使用spearman相关性，好处在于不考虑数据分布
cor.res
```

## 开始画图

这里提供两种绘图方式：baseplot，或pheatmap + pie + 后期

### 方法一：硬核baseplot直接画

**题外话：**使用baseplot绘图非常灵活，也是学习绘图思路的重要途径，但对于大多数使用者来说，复杂图形的baseplot很耗时，尤其是参数的微调。

如果希望快速出图，或者有一定PPT/AI技巧的小伙伴，可直接移步方法二，方法二采用pheatmap + pie + PPT/AI（后期）也能完美解决。

```{r}
showLayout = FALSE # 默认不在最终pdf的首页显示layout结构，不过建议初次绘制的时候改为TRUE看一下，方便理解
pdf("complex heatmap with pie charts by baseplot.pdf",width = 6,height = 4)

# 设置画面布局，相同数字代表同一区块，数字越多代表该区块所占面积越大
layout(matrix(c(1,1,1,1,1,1,1,2,
                3,3,3,3,3,3,3,4,
                3,3,3,3,3,3,3,5,
                3,3,3,3,3,3,3,6,
                3,3,3,3,3,3,3,7,
                3,3,3,3,3,3,3,8,
                3,3,3,3,3,3,3,9,
                3,3,3,3,3,3,3,10,
                11,11,12,12,12,12,13,13),
              byrow = T,nrow = 9))

if(showLayout) {
  layout.show(n=13) # 直观展示画布分布
}

#-------------------------#
# 画布区域1：绘制图的标题 #
#-------------------------#

par(bty="n", mgp = c(0,0,0), mar = c(0,0,0,0)) # 基础参数，去掉边框，各边界距离为0
plot(1,1,
     col = "white", # 点设置为白色
     xlab = "",xaxt = "n", # 不显示x坐标轴
     ylab = "",yaxt = "n") # 不显示y坐标轴
text((par("usr")[1]+par("usr")[2])/2, # 用par("usr")来获取该画布的绝对位置
     (par("usr")[3]+par("usr")[4])/2,
     "Special immune functions of TIM-3",cex = 1.8) # 显示图标题

#---------------------------#
# 画布区域2：绘制图的子标题 #
#---------------------------#

par(bty="n", mgp = c(0,0,0), mar = c(0,0,0,0))
plot(1,1,
     col = "white", # 点设置为白色
     xlab = "",xaxt = "n", # 不显示x坐标轴
     ylab = "",yaxt = "n") # 不显示y坐标轴
text((par("usr")[1]+par("usr")[2])/2, # 用par("usr")来获取该画图的绝对位置
     par("usr")[3]+0.3, # y绝对最低点+0.3
      "TCGA****",cex = 1.5) # 显示图标题

#---------------------------------#
# 画布区域3：绘制热图（主要区域） #
#---------------------------------#

par(bty="n", mgp = c(0,0,0), mar = c(0,6.1,0,0)) # mar参数只余留左侧空白给纵坐标写text

# 生成一个空白图
plot(c(0,ncol(enrich.go)),c(0,nrow(enrich.go)), # 产生左下和左上两个点，张开画布
     col = "white", # 点设置为白色
     xlab = "",xaxt = "n", # 不显示x坐标轴
     ylab = "",yaxt = "n", # 不显示y坐标轴
     xaxs="i", yaxs="i") # 重要：不余留画布任何空白（一般在0刻度下还有一些空白，这里全部抹去），保证扇形图恰好对准每一行热图

# 生成纵坐标
text(y = 0.5:(nrow(enrich.go)-0.5), # 生成坐标轴标签
     par("usr")[1], cex = 1.1,
     labels = rownames(enrich.go)[nrow(enrich.go):1], # 由下往上设置坐标
     srt = 0, pos = 2, xpd = TRUE)

# 产生颜色（这里不可能每一个数值就对应一个颜色，如果这样颜色区间会非常长，所以一般做法是把数值分割成块来映射颜色）
input_matrix <- enrich.go

tmp <- cut(input_matrix,breaks = seq(floor(min(input_matrix)),ceiling(max(input_matrix)),0.01)) # 分割富集得分，步长为0.01（如果希望颜色更加细腻可以步长缩短，但是没有必要）
rangeMat <- levels(tmp) # 拿到具有的分割区间

cutMat <- matrix(tmp, # 生成对应的分割矩阵
                 byrow = F, # 按列排列
                 nrow = nrow(input_matrix),
                 dimnames = dimnames(input_matrix)) # 赋予行名

rbPal <- colorRampPalette(rev(brewer.pal(n = 11, name = "RdYlBu"))) # 产生和例文一致的颜色区间函数
col.vec <- rbPal(length(rangeMat)) # 产生对应区间个数的颜色
names(rangeMat) <- col.vec # 将区间赋予颜色名（带名字的字符串，方便后面匹配用）

# 生成和富集得分矩阵对应的颜色矩阵
col.mat <- matrix(NA,byrow = F,ncol = ncol(input_matrix),nrow = nrow(input_matrix)) # 生成空的颜色矩阵
for (i in 1:nrow(input_matrix)) {
  for (j in 1:ncol(input_matrix)) {
    col.mat[i,j] <- names(rangeMat[rangeMat == cutMat[i,j]]) # 根据分割区间填充相匹配的颜色
  }
}

# 通过矩形块产生热图
x_size <- ncol(input_matrix)
y_size <- nrow(input_matrix)

my_xleft = rep(0:(x_size-1),each = y_size) # 产生各个矩形的左x点，注意是从上到下从左往右的顺序
my_xright = my_xleft + 1 # 产生各个矩形的右x点
my_ybottom = rep((y_size-1):0, x_size) # 产生各个矩形的下y点
my_ytop = my_ybottom + 1 # 产生各个矩形的上y点

rect(xleft = my_xleft,
     ybottom = my_ybottom,
     xright = my_xright,
     ytop = my_ytop,
     col=col.mat, # 填充颜色
     border = NA) # 清除矩形的边界

#-----------------------------------#
# 画布区域4-10：绘制扇形图（共7个） #
#-----------------------------------#

# 汇总相关性分析结果
cor.dat <- NULL
for (i in 1:length(cor.res)) {
  tmp <- cor.res[[i]]
  # rho：相关性系数绝对值
  # supp_rho：1-|相关性系数|
  # p：相关性显著性
  # sign：保存相关系数的符号（重要：例文用于确定扇形颜色以及时针走向）
  cor.dat <- rbind.data.frame(cor.dat,data.frame(rho = abs(tmp$estimate),supp_rho = 1-abs(tmp$estimate),p = tmp$p.value,sign = ifelse(tmp$estimate > 0,"+","-"),stringsAsFactors = F))
}
rownames(cor.dat) <- row.names(enrich.go)

for (i in 1:nrow(cor.dat)) {
  if(cor.dat[i,"sign"] == "+") { # 判断相关系数符号
    clockwise = T # 若正相关则顺时针填充扇形图
    piecol <- rgb(1,0,0,cor.dat[i,"rho"]) # 根据相关性数决定rgb颜色中红色的透明度
  } else {
    clockwise = F # 若负相关则逆时针填充扇形图
    piecol <- rgb(0,1,0,cor.dat[i,"rho"]) # 根据相关性数决定rgb颜色中绿色的透明度
  }
  
  par(bty="n", mar = c(0,0,0,0))
  pie(c(cor.dat[i,"rho"],cor.dat[i,"supp_rho"]),
      col = c(piecol,"white"), # 第一个为相关系数的对应颜色，互补区块为白色
      radius = 1, # 扇形半径
      labels = NA, # 不显示任何图例
      init.angle = 90, # 填充扇形的初始角度，以保证从12点位置开始
      border = "grey40", # 扇形外缘灰色
      clockwise = clockwise) # 控制扇形方向
}

#----------------#
# 画布区域11：空 #
#----------------#

plot(1,1,
     col = "white", # 点设置为白色
     xlab = "",xaxt = "n", # 不显示x坐标轴
     ylab = "",yaxt = "n") # 不显示y坐标轴

#--------------------------#
# 画布区域12：绘制热图图例 #
#--------------------------#

par(mar=c(2.2,1,0.5,2),xpd = T)
barplot(rep(1,length(col.vec)),border = "NA", space = 0, # 生成条形图图例
        ylab="",
        xlab="",
        xlim=c(1,length(col.vec)),
        axes = F, col=col.vec) # 颜色区间
text(length(col.vec)/4,-0.9,"-0.5", adj=0.55,cex = 1.2) # 富集得分-0.5
text(length(col.vec)/2,-0.9,"0", adj=0.55,cex = 1.2) # 富集得分0
text(length(col.vec)/4*3,-0.9,"0.5", adj=0.55,cex = 1.2) # 富集得分0.5

#----------------#
# 画布区域13：空 #
#----------------#

plot(1,1,
     col = "white", # 点设置为白色
     xlab = "",xaxt = "n", # 不显示x坐标轴
     ylab = "",yaxt = "n") # 不显示y坐标轴

invisible(dev.off())
```

![](complex heatmap with pie charts by baseplot.pdf)

### 方法二：pheatmap + pie + PPT/AI（后期）

**题外话：**个人觉得complexheatmap也能实现，但我在教程里没发现添加pie chart的例子，所以只能等待其他小伙伴去挖掘啦。

方法二依赖输出子图再后期拼接的方式，方便快捷，对有PPT/AI基础的小伙伴很友好，推荐使用。

```{r}
# 输出子热图
pheatmap(enrich.go,
         cluster_rows = F,
         cluster_cols = F,
         show_rownames = T,
         show_colnames = F,
         color = col.vec,
         main = "Special immune functions of TIM-3 (TCGA)",
         filename = "subfigure of pheatmap.pdf")

# 循环输出每一张子扇形图pie
for (i in 1:nrow(cor.dat)) {
  if(cor.dat[i,"sign"] == "+") { # 判断相关系数符号
    clockwise = T # 若正相关则顺时针填充扇形图
    piecol <- rgb(1,0,0,cor.dat[i,"rho"]) # 根据相关性数决定rgb颜色中红色的透明度
  } else {
    clockwise = F # 若负相关则逆时针填充扇形图
    piecol <- rgb(0,1,0,cor.dat[i,"rho"]) # 根据相关性数决定rgb颜色中绿色的透明度
  }
  
  pdf(paste0("subfigure of pie for ",gsub(":","_",rownames(cor.dat)[i]),".pdf"),width = 3,height = 3)
  pie(c(cor.dat[i,"rho"],cor.dat[i,"supp_rho"]),
      col = c(piecol,"white"), # 第一个为相关系数的对应颜色，互补区块为白色
      radius = 1, # 扇形半径
      labels = c("",""), # 不显示任何图例
      init.angle = 90, # 填充扇形的初始角度，以保证从12点位置开始
      border = "grey40", # 扇形外缘灰色
      clockwise = clockwise) # 控制扇形方向
  invisible(dev.off())
}
```

当前文件夹会生成1个heatmap和多个pie的pdf文件

![](subfigure of pheatmap.pdf)

![](subfigure of pie for GO_0002842.pdf)

```{r}
sessionInfo()
```