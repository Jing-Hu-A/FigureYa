FigureYa189timeCindex
FigureYa189timeCindex
2025-5-20
Auhtor：Xiaofan Lu
Reviewer：Ying Ge
需求描述Requirement description
FigureYa85timeAUC是时间依赖的auc曲线，我想要时间依赖的c-index，没法用之前的包画。FigureYa85timeAUC is a time-dependent auc curve. I want a time-dependent c-index, which cannot be drawn using the previous package.
出自from
https://doi.org/10.1007/s12035-018-1416-y
Fig. 5 Performance evaluation of the 8 lncRNA-based risk score. d Concordance index showing measure of concordance of predictor with survival of patients in TCGA
UVA8 outperforms all existing lncRNA-based survival models at different times after diagnosis (Fig. 5d). As expected, prognostic signatures that were specific to GBMs (Zhang6_2013 and Zhou6_2017) show poor concordance index when used to predict survival of lower grade glioma patients.
应用场景Application scenarios
时间依赖性C-index，评价不同模型的一致性指数。Time-dependent C-index, evaluating the consistency index of different models.
环境设置Environmental Settings
使用国内镜像安装包Use the domestic mirror installation package
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")
install.packages("pec")
install.packages("riskRegression")
加载包Loading package
library(survival)
library(pec)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息Display an English error message
options(stringsAsFactors = FALSE) #禁止chr转成factor# Prohibit converting chr to factor
输入文件Input file
easy_input.csv，包括由多变量Cox + LASSO惩罚得到的riskscore，以及两个临床变量（age、stage），还有time-to-event数据。跟FigureYa187RMS的easy_input.csv是同一个文件。easy_input.csv includes riskscore obtained from multivariate Cox + LASSO penalties, as well as two clinical variables (age, stage), and time-to-event data. easy with FigureYa187RMS_input.csv is the same file.
dat <- read.csv("easy_input.csv", row.names = 1,header = T,check.names = F,stringsAsFactors = F)
dat <- as.data.frame(na.omit(dat)) # 移除数据空值Remove the null values in the data
dat$OS.time <- dat$OS.time/365 # 将时间转化为以年为单位Convert time into units of years
head(dat)
构建模型用于time-dependent c-index的比较Construct a model for the comparison of time-dependent c-index
这里利用cox比例风险构建几种预后模型。可以替换成其他模型。Here, several prognostic models are constructed using cox proportional hazards. It can be replaced with other models
cox1 <- coxph(Surv(OS.time,OS)~Riskscore,data = dat,x=TRUE,y=TRUE) # 第一个模型仅考虑风险得分The first model only considers the risk score
cox2 <- coxph(Surv(OS.time,OS)~Age,data = dat,x=TRUE,y=TRUE) # 第二个模型仅考虑年龄The second model only considers age
cox3 <- coxph(Surv(OS.time,OS)~Stage,data = dat,x=TRUE,y=TRUE) # 第三个模型仅考虑分期The third model only considers periods
cox4 <- coxph(Surv(OS.time,OS)~Age + Stage,data = dat,x=TRUE,y=TRUE) # 第四个模型综合考虑年龄和分期The fourth model takes age and staging into comprehensive consideration
cox5 <- coxph(Surv(OS.time,OS)~Riskscore + Age,data = dat,x=TRUE,y=TRUE) # 第五个模型综合考虑得分和年龄The fifth model takes into account both score and age comprehensively
cox6 <- coxph(Surv(OS.time,OS)~Riskscore + Age + Stage,data = dat,x=TRUE,y=TRUE) # 第六个模型综合考虑所有变量The sixth model takes all variables into comprehensive consideration

# 创建公式（也可直接在算法里使用"."代表全部变量）Create a formula (it can also be directly used in the algorithm "; ") ." Representing all variables
# lhs = "Surv(OS.time, OS)"
# rhs = paste(setdiff(colnames(dat),c("OS","OS.time")),collapse = "+")
# form = as.formula(paste(lhs, "~", rhs))

# 设置种子以便结果可重复Set the seeds so that the results can be repeated
set.seed(123456) 

# 每一次cindex评估的时间点，越密集曲线越平滑，这里按每0.5年为一步长For each time point evaluated by the C-Index, the denser the time, the smoother the curve. Here, every 0.5 years is taken as a step length
eval.time <- seq(1,floor(max(dat$OS.time)),0.5) 

# 创建算法需要的对象，命名可以按照自己习惯的方式，或者后期AI调整也很方便Create the objects required by the algorithm. The naming can be done in the way you are accustomed to, or it is also very convenient for the AI to make adjustments later
obj <- list("cox1"=cox1,
            "cox2"=cox2,
            "cox3"=cox3,
            "cox4"=cox4,
            "cox5"=cox5,
            "cox6"=cox6)

timeC <- pec::cindex(object = obj,
                      #formula=form,
                      formula=Surv(OS.time,OS)~.,
                      data=dat,
                      eval.times=eval.time, 
                      splitMethod = "BootCv") # 使用bootstrap cross validation法计算（注意设置种子）Calculate using the bootstrap cross validation method (note to set the seed)
# 提出time-dependent Cindex结果Propose the time-dependent Cindex results
timeC.mat <- do.call(cbind,timeC$BootCvCindex) 
# 输出每个变量的Cindex的值Output the value of the Cindex for each variable
write.csv(timeC.mat, "output_cindex.csv", quote = F, row.names = eval.time)
开始画图Start drawing
# 获取cindex的最小值作为y轴的下界Obtain the minimum value of the c-index as the lower bound of the Y-axis
ymin <- min(timeC.mat) 

# 如果想用调色板，下面这行代码比较方便If you want to use a color palette, the following line of code is quite convenient
mycol <- RColorBrewer::brewer.pal(n = ncol(timeC.mat), name = 'Set2')
# 如果想自定义颜色，要自己设置足够多的颜色，如例文颜色If you want to customize colors, you need to set enough colors yourself, such as the colors in the example text
mycol <- c("#DFDFDF", "#999999", "#FDD7C2", "#ED7F54", "#C04658", "#050505")

pdf("time-dependent Cindex.pdf",width = 6,height = 5.5)
par(bty="l", #如果想要例文那样坐标轴分开的，就把l改为n  If you want the coordinate axes to be separated as in the example, change l to n
    mgp = c(1.9,.33,0), mar=c(4.1,4.1,2.1,2.1)+.1, las=1, tcl=-.25) # 基础画板设置Basic drawing board Settings

# 循环绘制折线Draw broken lines in a loop
for (i in 1:ncol(timeC.mat)) { 
  if(i == 1){ # 当绘制第一根cindex折线时plot完整画布plot the entire canvas when the first C-index line is drawn
    plot(eval.time,timeC.mat[,i],
         type="l",
         col = mycol[i],
         lwd = 2,
         ylim = c(ymin,1),xlim = range(dat$OS.time),
         xaxt = "n",
         xlab="Time (Years)",ylab = "Concordance index")
    axis(side = 1,
         at = seq(0,max(eval.time),1),
         labels = seq(0,max(eval.time),1))
  } else { # 随后添加折线Then add a broken line
    lines(eval.time,timeC.mat[,i],
          col = mycol[i],
          lwd = 2)
  }
}
# 例文在0.5处画了阈值线，因为0.5为“猜测”线The sample text draws a threshold line at 0.5 because 0.5 is a "guess" line
# if(ymin < 0.5) {abline(h = 0.5,lty = 4,col = "grey50",lwd = 2)} # 如果cindex矩阵中最小值小于0.5，则绘制y=0.5处的虚线为阈值If the minimum value in the C-index matrix is less than 0.5, draw the dotted line at y=0.5 as the threshold

# 个人建议以0.6为阈值，因为cindex认为有效的最低阈值为0.6Personally, I suggest setting the threshold at 0.6, as the minimum threshold that the cindex considers effective is 0.6
if(ymin < 0.6) {abline(h = 0.6,lty = 4,col = "grey50",lwd = 2)} # 如果cindex矩阵中最小值小于0.5，则绘制y=0.5处的虚线为阈值If the minimum value in the C-index matrix is less than 0.5, draw the dotted line at y=0.5 as the threshold

# 绘制图例Draw a legend
legend("topright", # 图例位于右上角 The legend is located in the upper right corner
       legend = colnames(timeC.mat),
       col = mycol,
       lty = 1,
       lwd = 2,
       y.intersp = 1, x.intersp = 0.5, # 各行图例的间距细节The spacing details of each row legend
       bty = "o") # 图例保留边框The legend retains the border
invisible(dev.off()) # 关闭图像句柄Close the image handle
Session Info
sessionInfo()