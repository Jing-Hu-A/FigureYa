FigureYa163twoVarCor_update
FigureYa163twoVarCor_update
Date：2025-5-20
Author：Xiaofan Lu
Reviewer：Ying Ge、Junyi Shen
需求描述Description of requirements
需求一：
绘制多组数据在两个变量上的相关性散点图。Requirement 1:
Draw a scatter plot of the correlation of multiple sets of data on two variables.
Fig. 1 Correlations between DNAm age and chronological age and other molecular characteristics of DNAm age groups. a DNAm age of 200 mixed normal cervical samples predicts chronological age with a decent correlation coefficient, whereas such correlation was much weaker in 252 tumour samples from TCGA.
图的解读Interpretation of the figure
不同于普通相关性散点图，这里添加了更丰富的信息，类似的有Unlike normal correlation scatter plots, richer information is added here, and similar ones are FigureYa143survCor：
用点的大小展示横纵坐标的差异，类似于FigureYa59vocano用点的大小体现差异倍数和pvalue；The size of the dots is used to show the difference in the vertical coordinates, similar to FigureYa59vocano, which uses the size of the dots to reflect the difference multiple and pvalue
用了两种颜色，使得两组数据可以画一起，还可用更多颜色展示更多组。Two colors are used so that the two sets of data can be drawn together, and more groups can be displayed with more colors
需求二：
审稿人要求我比较两个相关性大小有没有统计学差异，我想知道老师这篇文章里Fisher’s r-to-z transformation是怎么计算的？Requirement 2:
The reviewer asked me to compare whether there is a statistical difference between the two correlation magnitudes, and I want to know how Fisher's r-to-z transformation is calculated in this article.
出自From
https://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-020-0822-y
应用场景Application scenarios
展示两个基因/性状之间的相关性，2组/3组/多组都可以画一起Show the correlation between two genes/traits, 2 groups/3 groups/multiple groups can be drawn together。
这里用颜色区分每个分组，如果太多怕区分不开，可参考FigureYa125Fishertest、FigureYa76corrgram或FigureYa97correlationV3，再多的话可以用FigureYa73batchCorrelation做批量相关性分析和画图。可进入“微店——分类——相关性”，查看更多相关性的展示方式。Here you use color to distinguish each grouping, if you are afraid that you can't distinguish too much, you can refer to FigureYa125Fishertest, FigureYa76corrgram or FigureYa97correlationV3, if there are more, you can use FigureYa73batchCorrelation for batch correlation analysis and drawing. You can enter "Micro Store - Classification - Relevance" to see more relevance display methods.
这里要求两组数据的横纵坐标一致，如果你的两组数据横纵坐标不一致，可参考FigureYa62twoAxis和FigureYa96R2的画法If your two sets of data are inconsistent, you can refer to the drawing method of FigureYa62twoAxis and FigureYa96R2
环境设置Environment settings
Sys.setenv(LANGUAGE = "en") #显示英文报错信息Displays the error message in English
options(stringsAsFactors = FALSE) #禁止chr转成factor  Prohibiting CHR from converting to factor
自定义函数，用于比较不同组相关性是否有统计学差异Custom functions to compare whether there are statistical differences in correlations between groups
test2cor = function(x1, x2, y1, y2, method = "pearson") {
  
  # x1：第一组相关性分析的变量1The first set of variables for correlation analysis 1
  # x2：第一组相关性分析的变量2The first set of variables for correlation analysis 2
  # y1：第二组相关性分析的变量1The second set of variables for correlation analysis 1
  # y2：第二组相关性分析的变量2The second set of variables for correlation analysis 2
  # method：相关性分析方法，默认为皮尔斯相关性Correlation analysis method, default to Pierce correlation
  
  # 统计定义： Fisher’s r-to-z transformation was used to calculate a value of z that was applied to assess the significance of the difference between two correlation coefficients. 

  cor1 = cor.test(x1, x2, method = method)
  cor2 = cor.test(y1, y2, method = method)
  
  r1 = cor1$estimate
  r2 = cor2$estimate
  n1 = sum(complete.cases(x1, x2))
  n2 = sum(complete.cases(y1, y2))
  fisher = ((0.5*log((1+r1)/(1-r1)))-(0.5*log((1+r2)/(1-r2))))/((1/(n1-3))+(1/(n2-3)))^0.5
  
  p.value = (2*(1-pnorm(abs(fisher))))
  
  result= list(
    "cor1" = list(
      "estimate" = as.numeric(cor1$estimate),
      "p.value" = cor1$p.value,
      "n" = n1
    ),
    "cor2" = list(
      "estimate" = as.numeric(cor2$estimate),
      "p.value" = cor2$p.value,
      "n" = n2
    ),
    "p.value.twosided" = as.numeric(p.value), # 双侧检验p值The p-value was tested two-sidedly
    "p.value.onesided" = as.numeric(p.value) / 2 # 单侧检验p值，根据相关性大小自行判断是“greater”还是“less”Unilateral test p-value, judge whether it is "greater" or "less" according to the correlation size
  )
  cat(paste(sep="",
            "cor1: r=", format(result$cor1$estimate, digits=3), ", p=", format(result$cor1$p.value, digits=3), ", n=", result$cor1$n, "\n",
            "cor2: r=", format(result$cor2$estimate, digits=3), ", p=", format(result$cor2$p.value, digits=3), ", n=", result$cor2$n, "\n",
            "diffence: p(one-sided)=", format(result$p.value.onesided, digits=3), ", p(two-sided)=", format(result$p.value.twosided, digits=3), "\n"
  ))
  return(result);
}
输入文件Enter the file
easy_input.csv，第一列和第二列是连续变量，分别对应图上的横纵坐标，第三列是分组。The first and second columns are continuous variables, corresponding to the horizontal and vertical coordinates on the graph, respectively, and the third column is grouping
cor.data <- read.csv("easy_input.csv", row.names = NULL, check.names = F, header = T, stringsAsFactors = F)
head(cor.data)
dim(cor.data)
table(cor.data$class)
分别计算不同组的相关性Correlations for different groups are calculated separately
# 第一组Group I
t.cor <- cor.test(cor.data[which(cor.data$class == "T"), "age"], cor.data[which(cor.data$class == "T"), "dnamage"])
t.cor
# 第二组Group 2
n.cor <- cor.test(cor.data[which(cor.data$class == "N"), "age"], cor.data[which(cor.data$class == "N"), "dnamage"])
n.cor
比较不同组相关性是否有统计学差异Compare whether there is a statistical difference in correlations between groups
直接在屏幕上打印两次相关性的差异显著性Print the difference significantly between the two correlations directly on the screen
cor.diff <- test2cor(x1 = cor.data[which(cor.data$class == "T"), "age"], 
                     x2 = cor.data[which(cor.data$class == "T"),"dnamage"],
                     y1 = cor.data[which(cor.data$class == "N"), "age"], 
                     y2 = cor.data[which(cor.data$class == "N"), "dnamage"])
开始画图Start drawing
先计算画图时需要的额外变量Calculate the additional variables needed to draw first
# 计算散点图里点的大小，根据自己的数据来调整公式Calculate the size of the dots in the scatter plot and adjust the formula according to your data
cor.data$diff <- abs(cor.data$dnamage - cor.data$age) # 计算甲基化加速年龄Calculate the age of accelerated methylation
cor.data$size <- log10(cor.data$diff + 1) # 根据加速程度计算散点大小The scatter size is calculated based on the degree of acceleration

# 计算图例里点的大小Calculate the size of the dots in the legend
cor.data$range <- cut(cor.data$size, breaks = quantile(cor.data$size), include.lowest = T) # 分配散点大小区间Assign scatter size intervals
cor.data$range2 <- as.numeric(gsub("]", "", sapply(strsplit(as.character(cor.data$range),","), "[",2), fixed = T)) # 取区间的后半部分，用于绘制图例Take the second half of the interval and use it to draw the legend
head(cor.data)
# 计算图例里需要绘制多少圆圈Calculate how many circles need to be drawn in the legend
num <- length(unique(cor.data$range2)) 
num
# 计算坐标轴的范围Calculate the range of the coordinate axis
ylim <- range(cor.data$dnamage) # y轴范围Y-axis range
xlim <- range(cor.data$age) # x轴范围X-axis range
画图Drawing
pdf("TwoVarCor.pdf", width = 7, height = 6.5)
par(bty="o", mgp = c(2,0.5,0), mar = c(4.1,4.1,2.1,4.1), tcl=-.25, font.main=3) # 画布基本设置Canvas basic settings
par(xpd=F) # 禁止显示超过画布的部分It is forbidden to display sections that exceed the canvas
plot(NULL, NULL, ylim = ylim, xlim = xlim, # 先绘制一个空的画布，仅有边框和坐标名Draw an empty canvas with only the border and coordinate names
     xlab = "Chronological age ", ylab = "DNA methylation age",col="white",
     main = "")
rect(par("usr")[1], # 给画布设置背景色，掩盖边框Set a background color to the canvas to cover the border
     par("usr")[3],
     par("usr")[2],
     par("usr")[4],
     col = "#EAE9E9",
     border = F)
grid(col = "white", lty = 1, lwd = 1.5) # 添加网格Add a grid

## 画散点和回归线Draw scatters and regression lines
# 在画布中添加一组（肿瘤组）的散点Add a set of scatters (tumor group) to the canvas
tmp1 <- cor.data[which(cor.data$class == "T"),]
reg1 <- lm(dnamage~age, data=tmp1) # 计算回归线Calculate the regression line
points(tmp1$age, tmp1$dnamage,
       pch = 19,
       col = ggplot2::alpha("#E51718",0.8), # 重叠散点透明化Overlapping scatter transparency
       cex = tmp1$size)
abline(reg1, lwd = 2, col = "#E51718") # 添加回归线Add a regression line

# 在画布中添加另一组（正常组）的散点Add another set of scatters (normal group) to the canvas
tmp2 <- cor.data[which(cor.data$class == "N"),]
reg2 <- lm(dnamage~age, data=tmp2)
points(tmp2$age, tmp2$dnamage,
       pch = 19,
       col = ggplot2::alpha("#1D2D60",0.8),
       cex = tmp2$size)
abline(reg2, lwd = 2, col = "#1D2D60")

# 如果有更多组，就按照以上格式依次添加。If there are more groups, add them in order according to the above format.

## 画顶部和右侧地毯线Draw the top and right carpet lines
# 添加边际地毯线显示数据分布情况Add marginal carpet lines to show the distribution of data
rug(cor.data$age, col="black", lwd=1, side=3)
rug(cor.data$dnamage, col="black", lwd=1, side=4)

## 添加相关性结果Add correlation results
# 本人不太会用expression和paste的组合，所以是直接写进去的I don't know how to use the combination of expression and paste, so I wrote it directly
# 手动把"~rho~" = 后面的数值修改为t.cor和n.cor的数值Manually change the values after "~rho~" = to the values of t.cor and n.cor
text(20,150, # 根据自己的数据调整位置Adjust your position based on your own data
     adj = 0,expression("Tumour: N = 252; "~rho~" = 0.30; "~italic(P)~" < 0.001"), col = c("#E51718"), cex=1)
text(20,140, # 根据自己的数据调整位置Adjust your position based on your own data
     adj = 0,expression("Normal: N = 200; "~rho~" = 0.82; "~italic(P)~" < 0.001"), col = c("#1D2D60"), cex=1)

# 允许绘制超过画布的部分（用于添加图例）Allows drawing more than the canvas (for adding legends)
par(xpd = T)

## 画图例Draw a legend
# 做散点的圆圈Make scattered circles
points(x = rep(par("usr")[2] + 2.2, num), 
       y = seq(80,60, # 根据自己的数据调整位置Adjust your position based on your own data
               length.out = num),
       pch = 19,
       bty = "n",
       cex = sort(unique(cor.data$range2)),
       col = "black")

# 做散点图例的文字Make the text of the scatter legend
text(x = rep(par("usr")[2] + 3.8, num + 1), y = c(95, seq(80,60,length.out = num)),
     labels = c("Absolute\nVertical\nShift",
                round(10^(sort(unique(cor.data$range2))) - 1,0)), # 还原对数转化Restore logarithmic transformations
     adj = 0,cex = 0.8)

# 做分组的圆圈（肿瘤和正常）Make circles for grouping (tumor and normal)
points(x = rep(par("usr")[2] + 2.2, 2), y = c(130, 120),
       pch = 19,
       bty = "n",
       cex = 1.8,
       col = c("#E51718","#1D2D60"))

# 做分组图图例的文字Make the text of the grouping diagram legend
text(x = rep(par("usr")[2] + 3.8, num + 1), y = c(130, 120),
     labels = c("Tumour","Normal"),
     adj = 0,cex = 0.8)

# 添加画布的边框Add a border for the canvas
par(new = T, bty="o")
plot(-1, -1,
     col = "white",
     xlim = xlim, ylim = ylim,
     xlab = "", ylab = "",
     xaxt = "n", yaxt = "n")
invisible(dev.off())
# 最终图可在AI里稍加修饰The final image can be slightly modified in the AI
Session Info
sessionInfo()