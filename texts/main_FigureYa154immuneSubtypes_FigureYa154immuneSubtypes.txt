FigureYa154immuneSubtypes
FigureYa154immuneSubtypes
Date：2025-5-20
Author:Yufang Wang
Reviewer:Ying Ge、Junyi Shen
需求描述Description of requirements
复现文章里的结果图Reproduce the result graph in the article
出自From
https://doi.org/10.1016/j.immuni.2018.03.023
Figure 1. Immune Subtypes in Cancer (A) Expression signature modules and identification of immune subtypes.
Top: Consensus clustering of the pairwise correlation of cancer immune gene expression signature scores (rows and columns). Five modules of shared associations are indicated by boxes.
Middle: Representative gene expression signatures from each module (columns), which robustly reproduced module clustering, were used to cluster TGCA tumor samples (rows), resulting in six immune subtypes C1–C6 (colored circles).
Bottom: Distributions of signature scores within the six subtypes (rows), with dashed line indicating the median.
原文作者提供了代码The original author provided the code to reproduce the signature scores and clusters，
https://github.com/Gibbsdavidl/Immune-Subtype-Clustering
。NOTE! This method is very sensitive to the software pipeline used in quantifying genes. It does not work well with FPKM, RPKM, TPM, etc.
后来又写了个R包Later, I wrote an R package
ImmuneSubtypeClassifier
，more robust，
https://github.com/Gibbsdavidl/ImmuneSubtypeClassifier
，感兴趣的小伙伴可以去研究一下。Interested friends can study it.
应用场景Application scenarios
按免疫浸润定量结果给样本分类。Samples were classified according to the quantitative results of immunoinfiltration
环境设置Environment settings
使用国内镜像安装包Use the domestic mirror installation package
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
library(devtools)
install_github("Gibbsdavidl/ImmuneSubtypeClassifier")
加载包Load the package
library(ConsensusClusterPlus)
library(corrplot)
library(ggplot2)
library(dplyr)
library(reshape2)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息Displays the error message in English
options(stringsAsFactors = FALSE) #禁止chr转成factor Prohibiting chr from converting to factor
输入文件Enter the file
mmc2.xlsx，即例文的Table S1，包含TCGA里33种癌症1万多个样本的免疫浸润结果。Table S1 in the example text contains the results of immune infiltration of more than 10,000 samples from 33 cancers in TCGA
We integrated major immunogenomics methods to characterize the immune tumor microenvironment (TME) across 33 cancers analyzed by TCGA, applying methods for the assessment of total lymphocytic infiltrate (from genomic and H&E image data), immune cell fractions from deconvolution analysis of mRNAseq data, immune gene expression signatures, neoantigen prediction, TCR and BCR repertoire inference, viral RNA expression, and somaticDNAalterations (Table S1).
实际应用时，可以提取其中某一种或相关的某几种癌症类型，做进一步分析。In practical application, one of them or related cancer types can be extracted for further analysis.
#下载输入文件Download the input file
#download.file("https://ars.els-cdn.com/content/image/1-s2.0-S1074761318301213-mmc2.xlsx","mmc2.xlsx")
#data <- readxl::read_xlsx("mmc2.xlsx")
#write.csv(data, "mmc2.csv", row.names = F)

#读入输入文件Read in the input file
data <- read.csv(file = "mmc2.csv", sep = ",", header = T, stringsAsFactors = T)
dim(data)
# 过滤50%缺失值的Filter 50% of the missing value
# data2 <- data[apply(data, 1, function(x){sum(is.na(x)) < length(x)/2}),]
data2 <- data[apply(data, 1, function(x){sum(is.na(x)) < ncol(data)/2}),]
my_data <- na.omit(data2)
dim(my_data)
STEP1: Consensus clustering of the pairwise correlation of cancer immune gene expression signature scres
data2 <- my_data[,-c(1,2,3,4)]
dim(data2)
data2 <- as.matrix(data2)
##生成聚类矩阵，并保存至setp01文件夹内Generate a clustering matrix and save it to the setp01 folder
res <- ConsensusClusterPlus(data2, maxK = 6, reps = 1000, 
                            pItem = 0.8, pFeature = 1, title="step01",
                            clusterAlg = 'hc', distance="spearman", seed=123456,
                            plot="pdf", #或or"png"
                            corUse="pairwise.complete.obs",writeTable=T)
选取
consensus matrix k=5
的图作为最上面的热图Select
the consensus matrix k=5
graph as the top heat map
STEP2: get the barcode plot of expression signatures of each Immune clusters
自定义函数Custom functions
genset_barcode <- function (data, gennset,
                            scale_col_low = "#053061", scale_col_mid = "white",
                            scale_col_high = "#67001f", 
                            scale_col_na = "grey50",
                            scale_name = NULL, 
                            scale_breaks = 5, 
                            scale_digits = 1,
                            x_breaks = waiver())
  {
  ggplot(data, aes_string("TCGA.Participant.Barcode", 1, fill = gennset)) +
    geom_tile() + 
    facet_wrap(.~Immune.Subtype, nrow = 6) + #用分面把6个cluster画一起Draw the 6 clusters together with the facet
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0,0)) + 
    scale_fill_gradient2(low = scale_col_low, 
                         mid = scale_col_mid, 
                         high = scale_col_high, 
                         na.value = scale_col_na,
                         midpoint = mean(data[[gennset]], na.rm = TRUE), 
                         name = scale_name,
                         breaks = function(x) seq(x[1], x[2], 
                                                  length.out = scale_breaks),
                         labels = function(x) formatC(x, format = "f",
                                                      digits = scale_digits)) + 
    labs(colour = "geneset scores") +
    theme_void() +
    coord_flip() + #坐标轴互换Coordinate axis swap
    
    #图例legend
    theme(legend.title.align = 1,
          legend.position = 'top',
          legend.direction = "horizontal")
}
画图Drawing
my_data$IFN.gamma.Response <- as.numeric(as.character(my_data[,'IFN.gamma.Response']))
my_data$TCGA.Participant.Barcode <- as.numeric(as.factor(as.character(my_data[,'TCGA.Participant.Barcode'])))
#View(my_data)

# 用自定义函数画图Draw with a custom function
genset_barcode(my_data,"IFN.gamma.Response")
ggsave("step02/IFN.gamma.Response.pdf", width = 2, height = 8)

genset_barcode(my_data,"TGF.beta.Response")
ggsave("step02/TGF.beta.Response.pdf", width = 2, height = 8)

genset_barcode(my_data,"Macrophages")
ggsave("step02/Macrophages.pdf", width = 2, height = 8)

genset_barcode(my_data,"Lymphocytes")
ggsave("step02/Lymphocytes.pdf", width = 2, height = 8)

genset_barcode(my_data,"Wound.Healing")
ggsave("step02/Wound.Healing.pdf", width = 2, height = 8)
STEP3: get the signature score distributions show cluster differences
自定义函数Custom functions
#自定义绘图函数Custom drawing functions
genset_density <- function(data,gennset, 
                           scale_col_low = "#053061", scale_col_mid = "white",
                           scale_col_high = "#67001f", scale_col_na = "grey50",
                           scale_name = NULL, scale_breaks = 5, scale_digits = 1, 
                           x_breaks = waiver())
  {
  ggplot(data, aes_string(x=gennset, fill = "color", group = "color")) +
    geom_density() + 
    facet_wrap(Immune.Subtype~.,nrow = 6)+
    geom_vline(aes_string(xintercept = mean(my_data[[gennset]],na.rm = TRUE)),
               color = "black", linetype = "dashed", size = 1)+ 
    scale_fill_gradient2(low = scale_col_low,
                         mid = scale_col_mid, 
                         high = scale_col_high,
                         na.value = scale_col_na,
                         midpoint = mean(data[[gennset]], na.rm = TRUE), 
                         name = scale_name,
                         breaks = function(x) seq(x[1], x[2], length.out = scale_breaks),
                         labels = function(x) formatC(x, format = "f",
                                                      digits = scale_digits)) + 
    labs(colour = "scaled scores")+
    theme_void() +
    theme(legend.title.align = 1,
          legend.position = 'top',
          legend.direction = "horizontal")
}

#自定义归一化函数Customize the normalization function
normalization <- function(x){
  return((x-min(x))/(max(x)-min(x)))}
画图Drawing
my_data$Immune.Subtype <- as.factor(as.character(my_data$Immune.Subtype))

#生成并归一化映射颜色数值Generates and normalizes mapped color values
my_data$IFN.gamma.Response <- normalization(as.numeric(as.character(my_data[,'IFN.gamma.Response'],na.rm=TRUE)))
target1 <- summarise(group_by(my_data,Immune.Subtype),target1=mean(IFN.gamma.Response))
my_data1 <- merge(my_data,as.data.frame(target1),all=T)

my_data$TGF.beta.Response <- normalization(as.numeric(as.character(my_data[,'TGF.beta.Response'],na.rm=TRUE)))
target2 <- summarise(group_by(my_data,Immune.Subtype),target2=mean(IFN.gamma.Response))
my_data2 <- merge(my_data1,as.data.frame(target2),all=T)

my_data$Macrophages <- normalization(as.numeric(as.character(my_data[,'Macrophages'],na.rm=TRUE)))
target3 <- summarise(group_by(my_data,Immune.Subtype),target3=mean(Macrophages))
my_data3 <- merge(my_data2,as.data.frame(target3),all=T)

my_data$Lymphocytes <- normalization(as.numeric(as.character(my_data[,'Lymphocytes'],na.rm=TRUE)))
target4 <- summarise(group_by(my_data,Immune.Subtype),target4=mean(Lymphocytes))
my_data4 <- merge(my_data3,as.data.frame(target4),all=T)

my_data$Wound.Healing <- normalization(as.numeric(as.character(my_data[,'Wound.Healing'],na.rm=TRUE)))
target5 <- summarise(group_by(my_data,Immune.Subtype),target5=mean(Wound.Healing))
my_data5 <- merge(my_data4, as.data.frame(target5),all=T)

my_data5$color <- my_data2$target1+my_data2$target2
my_data5$color <- normalization(my_data5[,'color'])

#绘制图形Draw a graph
genset_density(my_data5, 'IFN.gamma.Response')
ggsave("step03/IFN.gamma.Response.pdf", width = 2, height = 8)

genset_density(my_data5, 'TGF.beta.Response')
ggsave("step03/TGF.beta.Response.pdf", width = 2, height = 8)

genset_density(my_data5, 'Macrophages')
ggsave("step03/Macrophages.pdf", width = 2, height = 8)

genset_density(my_data5, 'Lymphocytes')
ggsave("step03/Lymphocytes.pdf", width = 2, height = 8)

genset_density(my_data5, 'Wound.Healing')
ggsave("step03/Wound.Healing.pdf", width = 2, height = 8)
说明illustrate
C1-6的颜色区间不一致，如果需要统一，需要先整体求一个方差，然后映射回去。但是那样子的话，代码的可复制性就会降低。The color interval of C1-6 is inconsistent, and if it needs to be unified, you need to find a variance as a whole first, and then map it back. But then the code is less reproducible.
如果需要的话，过几天更新到V2版Update to V2 in a few days if needed。
可以先参考这篇You can refer to this article first
https://mp.weixin.qq.com/s/yVLgGQQi0CQ9Q9UfIKl5aA
后期处理Post-processing
输出的pdf文件是矢量图，可以用Illustrator等矢量图软件打开，拼接、编辑图形和文字。The output pdf file is a vector image, which can be opened with vector graphics software such as Illustrator to splice and edit graphics and text
sessionInfo()