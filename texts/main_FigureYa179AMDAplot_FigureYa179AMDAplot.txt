FigureYa179AMDAplot
FigureYa179AMDAplot
2025-5-20
Author：Enyu Lin
Reviewer: Ying Ge
需求描述Requirement:
重复文章中ageing-mediated disease alignment score (AMDA score)的算法，并复现原文的Figure3a。Repeat the algorithm for the ageing-mediated disease alignment score (AMDA score) in the article and reproduce Figure 3a in the original paper.
Fig. 3 Association of ageing-associated gene expression changes with ageing diseases and lifespan. a Ageing-mediated disease alignment scores (AMDA scores) for different ageing (x axis) and disease data sets (y axis). Abbreviations: AD Alzheimer’s disease, CAD coronary artery disease, CPI cancer proliferation index, cross-cohort cross-cohort study of blood ageing, HMP human metabolic pathways, IR insulin resistance, LL longitudinal ageing data, MCI mild cognitive impairment; SAFHS, San Antonio Family Heart Study.
出自from
https://www.nature.com/articles/s41467-017-02395-2
应用场景Application Scenarios
把自己的数据跟衰老联系起来，肿瘤、非肿瘤领域都可以用起来。具体原理参考下文的“AMDA score算法讲解”。Link your own data to aging, applicable to both oncology and non-oncology fields. For detailed principles, refer to the "AMDA score algorithm explanation" below.
适用于转录组数据，用文中的公式计算出样本的
AMDA score（量化衰老与疾病相关的指标）
，进行组间对比。This approach is applicable to transcriptome data. Use the formula provided to calculate the AMDA score (a quantitative indicator related to aging and disease) for each sample and compare them between groups.
也可以用自己的数据画这种
带有局部二级标签
的热图。You can also use your own data to create a heatmap with local secondary labels.
环境设置Environment Setup
使用国内镜像安装包Use a domestic image installation package.
options(BioC_mirror = "https://mirrors.tuna.tsinghua.edu.cn/bioconductor")
options(repos = structure(c(CRAN = "https://mirrors.tuna.tsinghua.edu.cn/CRAN/")))
if (!require("pacman")) install.packages("pacman")
pacman::p_load(svglite, ggplot2, magrittr, patchwork, Rmisc, Cairo, stringr, tidyr, 
    tidyfst, data.table, rlist, Hmisc, grid, gtable, gridExtra, ggpubr)
if (!require("DESeq2")) BiocManager::install("DESeq2")
if (!require("S4Vectors")) BiocManager::install("S4Vectors")
if (!require("BiocParallel")) BiocManager::install("BiocParallel")
加载R包Load R package
library(DESeq2)
library(S4Vectors)
library(BiocParallel)

Sys.setenv(LANGUAGE = "en")  #显示英文报错信息Display English error message
options(stringsAsFactors = FALSE)  #禁止chr转成factor，Disable conversion of chr to factor
如果你对AMDA score算法不感兴趣，只想画带二级分类标签的热图，就直接跳到“开始画图”。
If you're not interested in the AMDA score algorithm and just want to create a heatmap with secondary classification labels, skip to "Start Drawing."
AMDA score算法讲解AMDA Score Algorithm Explanation
要明白AMDA score得先看原文中的Figure 3a，其中分为两部分。To understand the AMDA score, first look at Figure 3a in the original paper, which is divided into two parts.
Part-1属于衰老基因集，是作者自己通过不同物种和组织经过年龄分层的多因素ANOVA进行计算所得的。衰老基因集包含了体现衰老信息的差异基因集，里面分为up和down（详见原文Supplementary Data）。衰老基因集是计算AMDA score的基础，但这个无法复现。因为衰老基因集是作者使用包括斑马鱼、非洲青鳉鱼、小鼠和人的各种组织以及纤维细胞系的基因组所计算得出的。所以，Part-1的基因集在Supplementary Data有提供，直接使用即可。Part-1 is the aging gene set, which was calculated by the authors themselves through multi-factor ANOVA stratified by age across different species and tissues. The aging gene set contains differential gene sets that reflect aging information, which are divided into up and down (see the original Supplementary Data for details). The aging gene set is the basis for calculating the AMDA score, but this cannot be reproduced. This is because the aging gene set was calculated by the authors using the genomes of various tissues including zebrafish, African medaka, mouse and human, as well as fibroblast cell lines. Therefore, the gene set of Part-1 is provided in the Supplementary Data and can be used directly.
Part-2是包括cancer、cvd等各种疾病的病人基因组数据，通过不同的分组策略（见原文Supplementary Table 5）后进行差异基因分析（Deseq2)。然后将差异结果里的log2 Foldchange（原文里描述的是Foldchange，其实实际上是log2FC）在进行normalization（详见下文
“计算AMDA score”
），最后得出取值范围为[-1,1]的log2FC值。Part 2 includes genomic data from patients with various diseases, including cancer and CVD. Differential gene expression analysis (Deseq2) was performed using different grouping strategies (see Supplementary Table 5). The log2 Foldchange (described as "Foldchange" in the original paper, but actually log2FC) in the differential results was normalized (see "Calculating AMDA Score" below for details), resulting in a log2FC value in the range [-1, 1].
AMDA score公式的分子部分表示某个病种中匹配到某个基因集中up组的差异基因的rank normalization后的log2FC值的和，减去匹配到down组的差异基因的log2FC的和。分母则是这个基因集中up和down组基因的总数量。The numerator of the AMDA score formula represents the sum of the rank-normalized log2FC values of the differentially expressed genes in the up group of a gene set for a given disease, minus the sum of the log2FC values of the differentially expressed genes in the down group. The denominator is the total number of genes in the up and down groups in the gene set.
下面以Part-2里的一种疾病为例，展示AMDA score 的计算过程。这里使用
TCGA-BLCA
的转录组数据进行计算（
为什么不用原文中所用的ICGC-BLCA数据，见文末 Q & ABelow, we'll use a disease from Part 2 as an example to demonstrate the AMDA score calculation process. We use transcriptome data from the TCGA-BLCA dataset (see the Q&A at the end of the article for reasons why the ICGC-BLCA dataset used in the original paper is not used).
）
输入数据预处理Input Data Preprocessing
实际应用时，如果已经准备好了基因表达矩阵，可跳过这步，直接进入“差异表达分析”。如果已经做好差异表达分析，就直接进入“输入文件”。In practice, if you already have a gene expression matrix, you can skip this step and proceed directly to "Differential Expression Analysis." If you've already completed differential expression analysis, proceed directly to "Input File."
中间文件已上传至微云The intermediate files have been uploaded to Weiyun: https://share.weiyun.com/c1ToPq7z
https://share.weiyun.com/c1ToPq7z
清洗TCGA-BLCA数据Cleaning TCGA-BLCA Data
这里为了复现原文，因此提取与原文匹配的样本名，用到ICGC-BLCA的转录组数据，但不用里面的raw.count。因ICGC-BLCA数据过大（1.67G），这里不再运行。感兴趣的小伙伴可以自己下载数据放入当前目录内运行。To replicate the original article, we extract sample names matching the original article and use the ICGC-BLCA transcriptome data, but without the raw.count function. Because the ICGC-BLCA data is too large (1.67GB), we will not run it here. Interested users can download the data and run it in their current directory.
为了方便可以直接导入我整理好的与文章中匹配的17对BLCA样本For convenience, you can directly import the 17 paired BLCA samples I've compiled that match the article.
差异表达分析Differential Expression Analysis
使用DEseq2，与原文一致，对TCGA-BLCA转录组进行差异表达分析。其中基因的row.count数没有进行过滤（比如某基因row.count总和<1的剔除），因为不影响差异结果（已验证）。DEseq2 was used to perform differential expression analysis of the TCGA-BLCA transcriptome, consistent with the original paper. Gene row.count filtering (e.g., removal of genes with a total row.count < 1) was not performed, as this did not affect the differential expression results (verified).
# 加载基因表达矩阵 肿瘤组Load the gene expression matrix for the tumor group
cases_tcga <- read.csv("easy_input_case.csv", row.names = 1, header = T, check.names = F)
cases_tcga[1:3, 1:3]

# 对照组Control group
control_tcga <- read.csv("easy_input_control.csv", row.names = 1, header = T, check.names = F)
control_tcga[1:3, 1:3]

## 合并肿瘤组和对照组Merge the tumor and control groups

rownames(cases_tcga) = cases_tcga$ENSG
cases_tcga = cases_tcga[, -ncol(cases_tcga)]
rownames(control_tcga) = control_tcga$ENSG
control_tcga = control_tcga[, -ncol(control_tcga)]
mRNA = cbind(cases_tcga, control_tcga)
type_tissue <- ifelse(as.numeric(substr(colnames(mRNA), 14, 15)) < 10, "tumor", "normal")
table(type_tissue)
type_tissue = relevel(factor(type_tissue), ref = "normal")
mRNA = round(mRNA, digits = 0)  #数据取整，DESeq2需要整数counts  Data rounding, DESeq2 requires integer counts
colData <- data.frame(row.names = colnames(mRNA), type = c(type_tissue))  #样本名+类别标签Sample name + category label

## 构建dds矩阵Build the DDS matrix
dds <- DESeqDataSetFromMatrix(countData = mRNA, colData = colData, design = ~type)

## 差异分析较久，创建文件方便保存结果Differential analysis takes a long time, so creating a file is convenient for saving the results.
tmp_f = file.path("mRNA.DESeq2-dds.Rdata")
register(SnowParam(6))  #设置多线程Set up multithreading
if (!file.exists(tmp_f)) {
    dds <- DESeq(dds, parallel = T)  #进行DESeq差异分析：估计大小因素，估算分散度，gene-wise分散估计，均值-色散关系，最终的分散估计(与原文描述一致)# Perform DESeq differential analysis: size factor estimation, dispersion estimation, gene-wise dispersion estimation, mean-dispersion relationship, and final dispersion estimation (same as described in the original paper)
    save(dds, file = tmp_f)
}  #最耗时（已启用多线程）#Most time-consuming (multithreading enabled)
load("mRNA.DESeq2-dds.Rdata")
res <- results(dds, tidy = F)
DEG = as.data.frame(res)  #转为数据框Convert to a data frame
head(DEG)
write.csv(DEG, file = "easy_input_DEG.csv")  #保存差异基因Save differentially expressed genes
对log2FC进行标准化，并对比原文提供的经标准化后的log2FC结果
这里使用上面计算的log2Foldchange(原文里描述的是Foldchange，实际上是log2FC(
已证实，详见 Q & A
))进行rank normalization
（原文里是先把所有disease的log2FC进行quantile normalization，再进行单个disease的rank normalization，因为这里只演示一个diseases所以无需进行quantile normalization）Here, we use the log2Foldchange calculated above (the original paper describes Foldchange, but it's actually log2FC (confirmed, see Q&A for details)) for rank normalization. (The original paper first performs quantile normalization on the log2FC of all diseases, then rank normalization on each disease. Since we only demonstrate a single disease here, quantile normalization is not necessary.)
STEP1: 先取绝对值进行大小排列，然后经(r-1)/(R-1)变换得出取值范围为[0,1]的log2FC值（
为什么是(r-1)/(R-1)变换而不是r/R变化，详见Q & A
）。Step 1: First, take the absolute values and rank them, then perform the (r-1)/(R-1) transformation to obtain a log2FC value in the range [0,1]. (Why is the (r-1)/(R-1) transformation used instead of the r/R transformation? See the Q&A for details.)
STEP2: 将取值范围为[0,1]的log2FC值加上log2FC值原有的正负号，使其取值范围变为[-1,1]。Step 2: Add the original sign of the log2FC value to the value range [0,1], so that the value range is [-1,1].
文章提供了一个包含3032个基因的几乎所有diseases（除了Cancer-CPI）的经标准化后的log2FC值（位于Supplementary Data S2）。这个文件与文中Figure3a中AMDA score无关，我们只用它来验证log2FC标准化的结果。The article provides standardized log2FC values for nearly all diseases (except Cancer-CPI) encompassing 3032 genes (in Supplementary Data S2). This file is unrelated to the AMDA score in Figure 3a; we used it only to verify the results of log2FC normalization.
画图查看相关性Draw a graph to view the correlation
ggplot(data = all_DEG, aes(x = rank, y = val)) + geom_point(color = "#ffb549") + 
    stat_smooth(method = "lm", se = T)
# 基本吻合Basically consistent
cor.test(all_DEG$rank, all_DEG$val, method = "pearson")
# 相关系数correlation coefficient >0.9
输入文件Input Files
需要用到差异表达分析结果和衰老基因集：You will need the following:
衰老基因集，用例文附件提供的多个文本文件，位于当前文件夹里的41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/The aging gene set uses the following text files, provided in the appendix of the example paper. These are located in the current folder: 41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/
easy_input_DEG.csv，前面用DESeq2获得的差异表达分析结果。easy_input_DEG.csv contains the differential expression analysis results obtained using DESeq2.
导入原文提供的所有衰老基因集Import all aging gene sets provided in the original paper.
可以把这套衰老基因集用到自己的paper里，记得引用原文哦～You can use this aging gene set in your own paper. Remember to cite the original paper.
metabolic <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/metabolic.txt", 
    sep = "")
breast <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/human-breast.txt", 
    sep = "")
skin <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/human-skin.txt", 
    sep = "")
human.daa <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/human-daa.txt", 
    sep = "")
human.muscle <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/human-muscle.txt", 
    sep = "")
metabolic <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/metabolic.txt", 
    sep = "")
SAFHS <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/human-blood-SAFHS.txt", 
    sep = "")
mouse.blood <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/mouse-blood.txt", 
    sep = "")
go <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/go.txt", 
    sep = "")
danio.brain <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/danio-brain.txt", 
    sep = "")
data.list = list.files("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/", 
    pattern = "*.txt")
all = list()
for (i in 1:length(data.list)) {
    x = read.csv(paste0("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DEGs/1-4+5/", 
        data.list[i]), sep = "")
    up = x[1:which(x$Up. == "Down:") - 1, 1]
    if (isEmpty(which(x$Up. == "Other:"))) {
        down = x[which(x$Up. == "Down:") + 1:nrow(x), 1]
    } else {
        down = x[((which(x$Up. == "Down:") + 1):(which(x$Up. == "Other:") - 1)), 
            1]
        all[[i]] = list(data.list[i], up, down)
    }
}
加载差异表达分析结果Loading differential expression analysis results
DEG <- read.csv("easy_input_DEG.csv", row.names = 1)
head(DEG)
计算AMDA score和p值Calculating the AMDA score and p-value
使用标准化后的log2FC值计算AMDA.score并计算p值。计算结果与原文的AMDA score基本吻合，偏差来源分析见Q & A。The normalized log2FC values were used to calculate the AMDA score and p-value. The calculated results are generally consistent with the original AMDA score. For an analysis of the source of the discrepancy, see the Q&A.
test = data.frame()
for (i in 1:length(data.list)) {
    n = unlist(all[[i]][1])  #name
    x = unlist(all[[i]][2])  #up
    y = unlist(all[[i]][3])  #down
    xx = table(x %in% row.names(DEG))
    yy = table(y %in% row.names(DEG))
    all_DEG = DEG[c(x, y), ]  #合并up和down基因集Merge up and down gene sets
    all_DEG = all_DEG[complete.cases(all_DEG), ]
    all_DEG$Foldchange = abs(all_DEG$log2FoldChange)  #绝对值log2FCAbsolute value log2FC
    all_DEG = all_DEG[order(all_DEG$Foldchange), ]  #标准化Standardization
    all_DEG$rank = c(0:(nrow(all_DEG) - 1))/(nrow(all_DEG) - 1)  #0开始0Start
    all_DEG$rank = all_DEG$rank * all_DEG$log2FoldChange/abs(all_DEG$log2FoldChange)
    res = (sum(na.omit(all_DEG[x, "rank"])) - sum(na.omit(all_DEG[y, "rank"])))/length(c(x, 
        y))
    a = wilcox.test(na.omit(all_DEG[x, "rank"]), na.omit(all_DEG[y, "rank"]), paired = FALSE, 
        exact = F, correct = TRUE, conf.int = FALSE, conf.level = 0.95)
    # Wilcoxon rank-sum test of normalized foldchanges of genes from a disease data
    # sets between ageing-repressed and ageing-induced genes(原文)(original text)
    test = rbind(test, cbind(n, res, a[["p.value"]], xx["TRUE"]/sum(xx), yy["TRUE"]/sum(yy)))
}
rownames(test) = c(1:nrow(test))
colnames(test) = c("fact", "AMDA.score", "AMDA.padj", "up%", "down%")
test$AMDA.score %<>% as.numeric()
test$AMDA.padj %<>% as.numeric()

# 把AMDA score保存到文件Save the AMDA score to a file
write.csv(test, "AMDAscore_output.csv", row.names = F, quote = F)
导入原文的AMDA score进行比较Import the original AMDA score for comparison
AMDA <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DiseaseAlignment-1-4+5/AMDA-dirs.csv")
test$oriAMDA = AMDA$cancer.bladder
ggplot(test, aes(x = AMDA.score, y = oriAMDA)) + geom_point(color = "#ffb549") + 
    stat_smooth(method = "lm", se = T)
cor.test(test$AMDA.score, test$oriAMDA, method = "pearson")
这里算出的AMDA score跟原文的相关系数为0.967。The correlation coefficient between the calculated AMDA score and the original paper is 0.967.
开始画图Start Plotting
以上BLCA的AMDA score对应图中的一行。实际应用时，如果有多组对比，可以像例文那样用热图展示；如果只有一组对比，可以换成柱形图或lollipop等方式展示。The AMDA score for the BLCA above corresponds to a row in the figure. In practice, if there are multiple comparisons, you can use a heatmap like in the example paper; if there is only one comparison, you can use a bar chart or lollipop.
这里复现文中的Figure 3a的带局部二级标签的heatmap。Here, we reproduce the heatmap with local secondary labels from Figure 3a in the paper.
输入文件预处理Input File Preprocessing
直接使用
文章的Supplementary Data S2的数据
复现Figure 3a，对照图来理解语句的含义。Directly reproduce Figure 3a using the data from the article's Supplementary Data S2. Compare the data to the figure to understand the meaning of the statement.
AMDA <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DiseaseAlignment-1-4+5/AMDA-dirs.csv")  #导入文中数据进行比对Import the data from the paper for comparison.
head(AMDA)
AMDA$X %<>% str_sub(end = -5)
heat <- pivot_longer(AMDA, -X, names_to = "diseases", values_to = "AMDA.score")
heat <- as.data.frame(heat)
Cancer <- heat$diseases[1:14]
Cardiovasculardiseases <- heat$diseases[15:21]
Neurodeg.diseases <- heat$diseases[22:26]
Type2diabetes <- heat$diseases[27:30]
Ageingsignature <- c("metabolic", "kegg", "go")
Speciesageing <- c("danio-liver", "danio-brain", "danio-skin", "notho-liver", "notho-brain", 
    "notho-skin", "mouse-liver", "mouse-brain", "mouse-skin", "mouse-blood", "human-skin", 
    "human-blood", "fibroblasts")
Externalhumandata = c("human-blood-cross-cohort", "human-blood-SAFHS", "human-muscle", 
    "human-brain", "human-breast", "human-daa")
LL = c("notho-longitudinal", "mouse-longitudinal")

heat$xx <- ifelse(heat$X %in% Ageingsignature, "Ageingsignature", ifelse(heat$X %in% 
    Speciesageing, "Speciesageing", ifelse(heat$X %in% Externalhumandata, "Externalhumandata", 
    "LL")))
heat$yy <- ifelse(heat$diseases %in% Cancer, "Cancer", ifelse(heat$diseases %in% 
    Cardiovasculardiseases, "Cardiovasculardiseases", ifelse(heat$diseases %in% Type2diabetes, 
    "Type2diabetes", "Neurodeg.diseases")))

heat$xx %<>% factor(levels = c("Ageingsignature", "Speciesageing", "Externalhumandata", 
    "LL"), ordered = T)
heat$yy %<>% factor(levels = c("Neurodeg.diseases", "Type2diabetes", "Cardiovasculardiseases", 
    "Cancer"), ordered = T)
heat$X %<>% factor(levels = c("go", "kegg", "metabolic", "danio-liver", "danio-brain", 
    "danio-skin", "notho-liver", "notho-brain", "notho-skin", "mouse-liver", "mouse-brain", 
    "mouse-skin", "mouse-blood", "human-skin", "human-blood", "fibroblasts", "human-blood-cross-cohort", 
    "human-blood-SAFHS", "human-muscle", "human-brain", "human-breast", "human-daa", 
    "notho-longitudinal", "mouse-longitudinal"), ordered = T, labels = c("Gene ontology", 
    "KEGG pathway", "HMP", "Liver", "Brain", "Skin", " Liver", " Brain", " Skin", 
    "  Liver", "  Brain", "  Skin", "Blood", "   Skin", " Blood", "Fibroblasts", 
    "   Blood (cross-cohort)", "Blood (SAFHS)", "Muscle", "   Brain", "Breast", "Digital ageing atlas", 
    "N. furzeri fin", "M. musculus ear"))
heat$diseases %<>% factor(levels = c(sort(names(table(heat[heat$yy == "Cancer", "diseases"])), 
    decreasing = T), sort(names(table(heat[heat$yy == "Cardiovasculardiseases", "diseases"])), 
    decreasing = T), sort(names(table(heat[heat$yy == "Type2diabetes", "diseases"])), 
    decreasing = T), sort(names(table(heat[heat$yy == "Neurodeg.diseases", "diseases"])), 
    decreasing = T)), ordered = T, labels = c("Uterus", "Skin", "Prostate", "Pancreas", 
    "Lung", "Liver", "
                                              Kidney", "Head & neck", 
    "CPI", "Colon & rectum", "Breast", "Brain", "Blood", "Bladder", "Stroke - blood 2", 
    "Stroke - blood 1", "Infarct - blood", "Hypertension - blood", "Heart failure - artery", 
    "CAD - plaque", "CAD - blood", "IR - adipose tissue", "Diabetes - liver", "Diabetes - islets 2", 
    "Diabetes - islets 1", "Parkinson - blood 2", "Parkinson - blood 1", "MCI - blood", 
    "AD - brain", "AD - blood"))

# x轴二级分类标签x-axis secondary classification label
tableGL <- data.frame(group = c(1:13), labels = rep(NA, 13), subgroup = c(rep("D. rerio", 
    3), rep("N. furzeri", 3), rep("M. musculus", 4), rep("H. sapiens", 3)))
tableGL$subgroup %<>% factor(levels = c("D. rerio", "N. furzeri", "M. musculus", 
    "H. sapiens"))

labx <- c(Ageingsignature = paste("Ageing", "\n", "signature"), Speciesageing = "Species ageing (JenAge data)", 
    Externalhumandata = paste("External human", "\n", "data"), LL = "LL")

# y轴二级分类标签y-axis secondary classification label
laby <- c(Cardiovasculardiseases = paste("Cardiovascular", "\n", "diseases"), Type2diabetes = paste("Type2", 
    "\n", "diabetes"), Neurodeg.diseases = paste("Neurodeg.", "\n", "diseases"), 
    Cancer = "Cancer")
画主图Draw the main image
s <- 10  #统一字体大小Unify font size
p_cor.order <- ggplot(heat, aes(X, diseases)) + geom_tile(aes(fill = round(AMDA.score, 
    2))) + theme(axis.text.y = element_text(size = s, face = "bold", margin = margin(r = 5)), 
    axis.title = element_blank(), axis.text.x = element_text(angle = 90, hjust = 1, 
        vjust = 0.3, face = "bold", size = s, margin = margin(t = 5)), legend.key.height = unit(0.2, 
        "inch"), legend.key.width = unit(0.25, "inch"), legend.text = element_text(size = s - 
        0.2), legend.background = element_blank(), legend.title = element_text(angle = 90, 
        vjust = -0.5, hjust = 0.5), plot.margin = unit(c(1, 2, 1, 1), "lines")) + 
    scale_fill_gradientn(limits = c(-0.42, 0.42), na.value = "#ff0000", breaks = c(-0.4, 
        -0.2, 0, 0.2, 0.4), labels = c("<-0.4", "-0.2", "0", "0.2", ">0.4"), values = c(0, 
        0.1, 0.5, 0.9, 1), colours = c("#0000ff", "#0000ff", "#ffffff", "#ff351c", 
        "#ff0000")) + guides(fill = guide_colourbar(title = "AMDA score", title.position = "right"))

# 加二级分类标签Add secondary classification labels
p1 <- p_cor.order + facet_grid(yy ~ xx, scales = "free", space = "free", switch = "both", 
    labeller = labeller(xx = labx, yy = laby)) + theme(strip.text = element_text(size = 11, 
    hjust = 0.5), strip.placement = "outside")

# 保存到文件save to file
pdf("AMDAplot_pri.pdf", width = 11, height = 9)
p1
dev.off()
输出的pdf文件是矢量图，可以用Illustrator等软件打开，手动编辑。The output PDF file is a vector image and can be opened and manually edited in software like Illustrator.
追求全自动，用代码画出物种拉丁名那行，下面会用到grid。如果理解有困难，可以到这里结束。For full automation, use code to draw the line containing the species' Latin names. A grid will be used later. If you have difficulty understanding, feel free to stop here.
画局部二级标签
p2 <- ggplot() + geom_text(data = tableGL, aes(label = labels, x = group), y = 0.5, 
    size = 0) + theme_pubr() + theme(axis.line = element_blank(), axis.ticks = element_blank(), 
    axis.text = element_blank(), axis.title = element_blank(), aspect.ratio = 1e-04/10000, 
    plot.margin = unit(c(6, 0.1, 0, 0.1), "lines")) + facet_grid(~subgroup, scales = "free_x", 
    space = "free_x", switch = "x") + theme(strip.text = element_text(size = 10, 
    hjust = 0.5, face = "italic"), strip.background = element_rect(fill = "#d9d9d9", 
    color = "#d9d9d9"))
# ——————转为grid对象Convert to a grid object
pg1 = ggplotGrob(p1)
pg2 = ggplotGrob(p2)
# ——————提取亚标签、合并Extract sub-labels and merge
pg2 <- gtable_filter(pg2, "(background|strip-b-[1234])", trim = T, invert = F)
pgn <- gtable_add_grob(pg1, pg2, t = 14, l = 9, r = 9, z = 2)
提取legend、添加上下文字、合并图层Extract the legend, add context words, and merge layers.
pgn2 <- gtable_filter(pgn, "(guide-box)", trim = T, invert = F)
pgn2 <- pgn2[["grobs"]][[1]][["grobs"]][[1]]  #去壳Remove the shell.
pgn <- gtable_filter(pgn, "(tag|guide-box|caption)", trim = T, invert = T)  #删除原有标签Delete the original label

Alignment <- textGrob("Alignment", gp = gpar(fontsize = 10))
Reversion <- textGrob("Reversion", gp = gpar(fontsize = 10))
padding <- unit(0.5, "line")

# 根据布局调整pos。Adjust pos according to layout.
gtable_show_layout(pgn2)
pgn3 <- gtable_add_rows(pgn2, heights = grobHeight(Alignment) + padding, pos = 0)
pgn3 <- gtable_add_rows(pgn3, heights = grobHeight(Reversion) + padding, pos = 6)
pgn3 <- gtable_add_grob(pgn3, list(Alignment), t = 1, l = 1, r = ncol(pgn3))
pgn3 <- gtable_add_grob(pgn3, list(Reversion), t = 6, l = 1, r = ncol(pgn3))
pgn <- gtable_add_grob(pgn, pgn3, t = 14, l = 6, r = 6, z = 13)  #合并，固定位置
输出图片Output picture
Q & A
1. 为什么确定原文用的log2FC标准化是(r-1)/(R-1)变换而不是r/R变换? 为什么说原文里描述的是Foldchange，实际上是log2FC？Why is it certain that the log2FC normalization used in the original paper is (r-1)/(R-1) transformation rather than r/R transformation? Why is it said that the original paper describes Foldchange, but is actually log2FC?
答：我们可以打开原文提供的包含3032个基因的经标准化后的FC值。A: We can open the normalized FC values for 3032 genes provided in the original paper.
ori <- read.csv("41467_2017_2395_MOESM5_ESM/Supplementary Data S2/DiseaseAlignment-1-4+5/normalizedFoldChanges.csv")
我们会发现，每一列是独立的disease，行是3032个基因，每一列按大小排列后值都是一样的We will find that each column is an independent disease, and each row is 3032 genes. After sorting by size, the values of each column are the same.
as.numeric(unlist(lapply(ori[, -1], max)))  #最大值Maximum value
as.numeric(unlist(lapply(ori[, -1], min)))  #最小值Minimum value
as.numeric(unlist(lapply(ori[, -1], median)))  #中位数Median
lapply(ori[, 2:5], function(x) {
    table(x > 0)
})  #这里可以看到每个样本正负的数量都是一样的，这是quantile normalization的证据（为了减少篇幅只取前几列）Here you can see that the number of positive and negative values for each sample is the same, which is evidence of quantile normalization (to reduce space, only the first few columns are included)
这里证实了作者是先对所有disease进行quantile normalization，也
说明了作者不是用foldchange
。如果使用foldchange，所有负值将变成最小的正值，当进行绝对值的rank normalization后加上原有的正负号会出现
最显著的负的log2FC会变成最不显著的负的log2FC
，这个可以自己去试一下。This confirms that the authors first performed quantile normalization on all diseases and also demonstrates that they did not use foldchange. If foldchange were used, all negative values would become the smallest positive value. When rank normalization of the absolute values is performed and the original sign is added, the most significant negative log2FC becomes the least significant negative log2FC. You can try this yourself.
接下来取某一列乘以3032，还原r/R变换Next, multiply a column by 3032 to restore the r/R transformation.
head(sort(abs(ori[, 2]) * 3032, decreasing = F))
这里发现*3032后最小值是0，而且其他数都不是整数，这与文章描述的不一致（原文：replaced fold-changes by their absolute ranks in the list of fold-changes）Here we find that the minimum value after *3032 is 0, and the other numbers are not integers, which is inconsistent with the description in the article (original text: replaced fold-changes by their absolute ranks in the list of fold-changes)
head(sort(abs(ori[, 2]) * 3031, decreasing = F))
# 换成*3031，结果都是整数完全符合(r-1)/(R-1)变换Replace with *3031, and the resulting integers perfectly match the (r-1)/(R-1) transformation.
2. 为什么不用原文中所用的ICGC-BLCA数据而用TCGA的？2. Why use the TCGA data instead of the ICGC-BLCA data used in the original paper?
答：ICGC-BLCA转录组数据中基因名是gene id和gene alias（基因别名）构成，这导致了很严重的问题。在基因ID转换的过程中（不管是用org.Hs.eg.db还是自己读取GTF进行匹配），会出现gene id与ensembl id多对多的情况。更严重的是，因为ICGC是gene id和gene alias混用，会导致某些gene alias匹配到其对应的gene id的ensembl id，也会出现一个ensembl id匹配到多个gene id和gene alias，导致多对多。这种结果会使得我们无法判断作者提供的normalizedFoldChanges.csv是属于ICGC里面的哪想基因（文中作者描述是使用Bimart进行转换，但Bimart同样也会遇到多对多转换，所以面临着随机性，可能某些gene id变成与其ensembl id下gene alias同名的gene id的ensembl id
（这也是复现这个图才发现的一个ID转换的坑！）
）。 因此，这次直接用TCGA-BLCA的数据，里面是ensembl id，直接使用即可，不过这也导致了下面的问题：计算结果偏差，
经对比发现，ICGC转录组的raw.count和TCGA的raw.count完全不一致（相同sample下）A: Gene names in the ICGC-BLCA transcriptome data consist of gene IDs and gene aliases, which leads to a serious problem. During the gene ID conversion process (whether using org.Hs.eg.db or reading the GTF for matching), many-to-many matches between gene IDs and ensembl IDs can occur. More seriously, because ICGC mixes gene IDs and gene aliases, some gene aliases can match the ensembl IDs of their corresponding gene IDs. This can also result in a single ensembl ID matching multiple gene IDs and gene aliases, leading to many-to-many matches.This result makes it impossible to determine which genes in the ICGC the normalizedFoldChanges.csv provided by the authors belong to. (The authors describe using Bimart for conversion, but Bimart also encounters many-to-many conversions, so it faces randomness, and some gene IDs may become ensembl IDs of gene IDs with the same name as the gene alias under their ensembl ID (this is also a pitfall of ID conversion that was discovered when reproducing this figure!). Therefore, this time we directly use the TCGA-BLCA data, which contains the ensembl ID, and can use it directly. However, this also leads to the following problem: deviation in the calculation results. A comparison found that the raw.count of the ICGC transcriptome is completely inconsistent with the raw.count of the TCGA (under the same sample).
。
3. 计算结果与原文的AMDA score的偏差是什么导致的？3. What causes the discrepancy between the calculated results and the AMDA score reported in the original article?
答：除了上面说的用了TCGA导致的偏差外，还有一个文章本身的原因。 通过读取文章Supplementary Data S2中所有作者自己计算出的衰老基因集发现，大多数衰老基因集的up和down个数与文章中Supplementary Table 3列出的个数不一致（记得只有metabolism是一致的）。这可能是作者在处理数据时出现的差错。A: In addition to the discrepancy mentioned above due to the use of TCGA, there's also a problem with the article itself. By reviewing all the aging gene sets calculated by the authors in Supplementary Data S2, we found that the up and down counts for most aging gene sets were inconsistent with the numbers listed in Supplementary Table 3 (remember, only the metadata was consistent). This is likely an error in the authors' data processing.
Session Info
sessionInfo()