---
title: "FigureYa51TMB_update"
author: "小丫画图出品"
date: "2020-7-16"
output: html_document
---
微信ID: epigenomics  E-mail: figureya@126.com

作者：小高

小丫编辑校验

更新：Byron

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

用某个基因的表达量来分组，画出各组的TMB box plot，带散点，计算p value。

![](example.png)

出自<https://www.nejm.org/doi/full/10.1056/NEJMoa1406498>

# 应用场景

借助突变数据TMB，把你的基因跟免疫治疗预后联系起来。

可以用某个基因的表达量高低来分组（或根据其他信息分组），对比不同分组的TMB值。

下一步，还可以用TMB值高低来分组，做生存分析。

# 环境设置

加载R包

```{r}
library(TCGAbiolinks)
library(dplyr)
library(stringr)
library(ggplot2)
library(ggpubr)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

# 用表达量分组

如果你的分组信息已经保存成`easy_input_group.csv`的格式，就可以跳过这步，直接进入“输入文件”。

## 从TCGA下载表达数据

如果你已经有表达数据，就可以跳过这步，直接进入“根据表达量给sample分组”

```{r, eval=FALSE}
expquery <- GDCquery(project = "TCGA-LIHC", 
                data.category = "Transcriptome Profiling",
                data.type = "Gene Expression Quantification",
                workflow.type = "HTSeq - FPKM")
GDCdownload(expquery)
expquery2 <- GDCprepare(expquery)
expMatrix <- TCGAanalyze_Preprocessing(expquery2)
dim(expMatrix)
expMatrix[1:3,1:4]

#只取肿瘤组织
group_list <- ifelse(substr(colnames(expMatrix),14,14)=='0','tumor','normal')
expMatrix_tumor <- expMatrix[,group_list=='tumor']
dim(expMatrix_tumor)

#保存一个基因的表达量，此处选取TP53，对应ID为ENSG00000141510
write.csv(expMatrix_tumor["ENSG00000141510",], "easy_input_expr.csv", quote=F, row.names = T)
```

## 根据表达量给sample分组

easy_input_expr.csv，某个基因在各个sample里的表达量。

第一列是sample ID，与突变数据里的sample ID一致；第二列是基因的表达量。

```{r}
myGene <- read.csv("easy_input_expr.csv")
colnames(myGene) <- c("Tumor_Sample_Barcode","Expr") #改列名
#保留barcode的前三个label
myGene$Tumor_Sample_Barcode <- str_sub(myGene$Tumor_Sample_Barcode,1, 12)
head(myGene)

# 用表达量中值分为两组
myGene$Expr_level <- ifelse(myGene$Expr > median(myGene$Expr),"high","low")
write.csv(myGene[,c(1,3)], "easy_input_group_2.csv", quote = F, row.names = F)

# 或者自己定义cutoff，分为更多组，例如三组
cutoff_low <- 3
cutoff_high <- 8
myGene$Expr_level <- cut(myGene$Expr, breaks = c(-Inf, cutoff_low, cutoff_high, Inf), labels = c("low","med","high"))
write.csv(myGene[,c(1,3)], "easy_input_group_3.csv", quote = F, row.names = F)
```

# 输入文件

需要TMB和分组文件（两组或更多组）。

mutation-load.txt，TCGA的TMB，来源于2018年的这篇文献：The Immune Landscape of Cancer <https://pubmed.ncbi.nlm.nih.gov/29628290/>，我们直接拿来用就好。

```{r}
# 加载分组
# 分两组的情况
myGroup <- read.csv("easy_input_group_2.csv")
myGroup$Expr_level <- factor(myGroup$Expr_level, levels = c("low", "high"))

# 分三组的情况
#myGroup <- read.csv("easy_input_group_3.csv")
#myGroup$Expr_level <- factor(myGroup$Expr_level, levels = c("low", "med", "high"))
head(myGroup)

# 加载TMB
myMut <- data.table::fread("mutation-load.txt",data.table = F)
# 其中Non-silent per Mb是TMB
head(myMut)

# 合并
TMB_clinical_mRNA <- myGroup %>%
  inner_join(myMut,by = c("Tumor_Sample_Barcode" = "Patient_ID")) %>%
  rename(TMB = 'Non-silent per Mb' ) 
head(TMB_clinical_mRNA)
```

# 开始画图

用ggplot2画图，用ggpubr算p value。

```{r, fig.width = 3, fig.height = 4}
mycol <- c("darkgreen", "darkorchid3", "orange") #与分组数量一致
p <- ggplot(TMB_clinical_mRNA, aes(x = Expr_level, y = TMB, color = Expr_level)) +
  geom_boxplot(outlier.color = NA) + #隐去箱线图上的异常点

  scale_color_manual(values = mycol) + #自定义配色
  
  stat_compare_means(#paired = T, #whether you want a paired test
                     #两组对比，用wilcox.test或t.test
                     method = "wilcox.test", 
                     
                     #多组对比，用kruskal.test或anova
                     #method = "kruskal.test",
                     label.y = max(TMB_clinical_mRNA$TMB)*1.1) + #label的位置
  
  theme_bw() + #去除背景色
  theme(panel.grid =element_blank()) + #去除网格线
  theme(panel.border = element_blank()) + #去除外层边框
  theme(axis.line = element_line(colour = "black")) + #沿坐标轴显示直线
  xlab("Discovery Set") + 
  #ylim(0,5) + #设置Y轴范围
  guides(color=FALSE) #不显示图例
p

# 绘制Wikinson点图
p + geom_dotplot(binaxis = "y", #沿y轴堆积，并沿着x轴分组
               binwidth = 0.5, #最大组距
               dotsize = 1, #点的大小
               #如果点太多，两组叠在一起，就需要运行下面这行把它们分开
               #stackgroups = T, binpositions="all",
               stackdir = "center")  #数量保持一致的中心堆叠方式
ggsave("TMB_dot.pdf")

# 或者散点图
p + geom_point(aes(group = Expr_level),
             alpha=.3, #点太多，设为透明色，就能看到叠加效果
             size = 2, #点的大小
             position="jitter") #分散
ggsave("TMB_point.pdf")
```

```{r}
sessionInfo()
```