---
title: "FigureYa40 lineages_analysis"
author: "小丫画图出品"
date: "2018-9-23"
output: html_document
---
微信ID: epigenomics  E-mail: figureya@126.com

作者：徐洲更<https://www.jianshu.com/u/9ea40b5f607a>

![](http://oex750gzt.bkt.clouddn.com/18-9-3/64881053.jpg)

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

用R画出文章里的这个图

![](http://oex750gzt.bkt.clouddn.com/18-9-11/92022740.jpg)

出自<https://www.cell.com/cell/abstract/S0092-8674(17)30596-2>

## 应用场景

细胞谱系分析，主要用于单细胞测序数据，展示细胞在二维状态空间的拟时间（pseudotime）排列，即一群细胞怎样变成另一群细胞。

## 软件安装

细胞谱系分析目前用到的包主要是[Monocle2](https://bioconductor.org/packages/release/bioc/html/monocle.html)

`monocle`需要通过`biocLite`安装，如果速度慢，将下面代码`#options(...)`中的`#`去掉，则会使用国内镜像. 

CRAN镜像备选

- 国科大: <https://mirrors.ustc.edu.cn/CRAN/>
- 同济大学: <https://mirrors.tongji.edu.cn/CRAN/>
- 兰州大学: <https://mirror.lzu.edu.cn/CRAN/>

```{r, message=FALSE, warning=FALSE}
#source("https://bioconductor.org/biocLite.R")
#options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
#options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
if ( ! require(monocle)) BiocInstaller::biocLite("monocle")
if ( ! require(DDRTree)) BiocInstaller::biocLite("DDRTree")
if ( ! require(pheatmap)) BiocInstaller::biocLite("pheatmap")
library(monocle)
library(DDRTree)
library(pheatmap)
```

## 输入数据

输入数据为两种:

- 表达量矩阵，行为基因名，列为样本(细胞)
- 样本的元数据(metadata)

> 测试数据集内存8G可能够用, 但是细胞数越多会对内存的要求更高。

**注**: 测试数据集的单细胞测序用的是SMART-Seq2, 因此表达矩阵需要进行TPM标准化, 参考"FigureYa23count2TPM"

如果用的是10X Genomics技术，表达矩阵是UMI，则不需要进行额外的TPM/FPKM标准化。

```{r}
exprs_file <- 'easy_input_TPM.txt'
metadata_file <- 'easy_input_sample_sheet.txt'
exprs_df <- read.table(file=exprs_file, sep='\t', header = TRUE, 
                 stringsAsFactors = FALSE, check.names = FALSE)
sample_sheet <- read.table(file = metadata_file, header = TRUE,
                           stringsAsFactors = FALSE)
```

数据来源于示例图所在的文章<https://www.cell.com/cell/abstract/S0092-8674(17)30596-2>

在GEO上根据[GSE98638](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE98638)下载raw count 数据。

由于文献分别对不同聚类进行细胞谱系分析，测试数据集选择了"C01_CD8-LEF1","C02_CD8-CX3CR1", "C04_CD8-LAYN","C05_CD8-GZMK"

```{r}
#查看数据的前几列, 以便后续进行数据整理
#exprs_df[1:10]

#这里的表达矩阵的第一列和第二列是基因的ID和symbol，后面的列都是每个细胞ID
sample_sheet[1:10,]
```

这里的第一列是细胞的ID，第二列是病人，第三列是聚类，第四列是细胞类型。一般第三列的聚类是通过Seurat分析得到, 参考"FIgureYa27tSNE"

## 构建newCellDataSet

后续分析依赖于Monocle, 所以要整理出三个数据集

- 表达量矩阵`exprs`:数值矩阵 行名是基因, 列名是细胞编号.
- 细胞的表型信息`phenoData`: 第一列是细胞编号，其他列是细胞的相关信息
- 基因注释`featureData`: 第一列是基因编号, 其他列是基因对应的信息

并且这三个数据集要满足如下要求:

表达量矩阵**必须**：

- 保证它的列数等于`phenoData`的行数
- 保证它的行数等于`featureData`的行数

而且

- `phenoData`的行名需要和表达矩阵的列名匹配
- `featureData`和表达矩阵的行名要匹配
- `featureData`至少要有一列"gene_short_name", 就是基因的symbol

先构建表达矩阵。根据之前对数据集的简单了解，原先的数据集前两列是不必要信息，所以要去掉，而行名对应第一列

```{r}
expr_matrix <- as.matrix(exprs_df[,c(-1,-2)])
rownames(expr_matrix) <- exprs_df[[1]]
expr_matrix[1:10,1:5]
```

再为`phenoData`准备数据框. 和之前导入的"sample_sheet"相符合, 只不过需要额外增加行名，即第一列

```{r}
sample_sheet <- sample_sheet
rownames(sample_sheet) <- sample_sheet[[1]]
```

接着为`featureData`准备数据框. 信息可以从exprs_df的前两列提取, symbol要改名成"gene_short_name"

```{r}
gene_annotation <- exprs_df[,c(1,2)]
rownames(gene_annotation) <- exprs_df[[1]]
colnames(gene_annotation)[2] <- "gene_short_name"
```

最后要比较下表达量矩阵的列数是否等于用于构建`phenoData`的sample_sheet.

如果发现不相同就需要根据表达矩阵的列来调整用于构建`phenoData`的sample_shee的行。

运行两次，看到结果为"run successfully"则表明顺利处理

```{r}
expr_col_name <- colnames(expr_matrix)
sample_sheet_row_name <- rownames(sample_sheet)

if ( ! identical(expr_col_name, sample_sheet_row_name)){
  data.frame(x=colnames(expr_matrix)[1:10],
  y=rownames(sample_sheet)[1:10])
} else {
  cat("run successfully")
}
if (all( sample_sheet_row_name %in% expr_col_name )){
  expr_matrix <- expr_matrix[,match(sample_sheet_row_name,expr_col_name)]
} else{
  warning("unequal row number")
}

```

最后构建Monocle后续分析要求的"newCellDataSet"对象, 注意根据输入数据的类型调整下面的`expressionFamily`参数。我们用的是TPM数据,所以用`tobit()`

- UMI: `negbinomial.size()	`
- FPKM, TPM: `tobit()`
- log-转换后的 FPKM/TPM： `gaussianff()`

```{r}
pd <- new("AnnotatedDataFrame", data=as.data.frame(sample_sheet))
fd <- new("AnnotatedDataFrame", data=as.data.frame(gene_annotation))
CDS <- newCellDataSet(expr_matrix, 
                      phenoData = pd,
                      featureData = fd,
                      expressionFamily = tobit())
```

如果expressionFamily选择的是`negbinomial.size()	`或者`negbinomial()`, 则还需要进行如下两步。

```{r}
#CDS <- estimateSizeFactors(CDS)
#CDS <- estimateDispersions(CDS)
```

## 细胞谱系分析

### 第一步:定义排序基因

排序基因的选择有很多种：

- 基于不同聚类的差异表达
- 基于已知的标记基因

从不同聚类中找到差异基因, 在聚类的基础上进行差异表达分析

单细胞聚类分析见"FIgureYa27tSNE"

```{r,warning=FALSE}
CDS <- detectGenes(cds = CDS , min_expr = 0.1)
expressed_genes <- row.names(subset(fData(CDS),
    num_cells_expressed >= 10))

#我的电脑8G内存，运行下面这行需要20分钟
#如果只为跑通代码，可以先跳过这步，直接进入下一段，读取压缩包里的“order_gene.txt”文件。
clustering_DEG_genes <- 
  differentialGeneTest(CDS[expressed_genes,],
                       fullModelFormulaStr = '~majorCluster',
                       cores=1)
ordering_genes <- row.names(clustering_DEG_genes)[order(clustering_DEG_genes$qval)][1:1000]
write.table(ordering_genes, "order_gene.txt",quote = F)
```

如果有一些已知基因，比如说上面做的差异表达分析的基因都是我们的已知基因，就可以直接导入

```{r}
ordering_genes <- read.table("order_gene.txt")[[1]]
```

最后设定用于排序的基因

```{r}
CDS <- setOrderingFilter(CDS, 
                         ordering_genes = ordering_genes)
```


### 第二步: 降维

这一步，比较耗费时间. 降维是为了更好的展示数据。

降维有很多种方法, 不同方法的最后展示的图都不太一样, 其中"DDRTree"是Monocle2使用的默认方法，ICA则是Monocle2的方法

```{r,warning=FALSE}
CDS <- reduceDimension(CDS, max_components = 2, 
                       method="DDRTress")
#把最耗时的这步保存下来，即使关闭了R，后面也可以直接从这步开始
#saveRDS(CDS, file="CDS_DDRTree.rds")
```

### 第三步: 在谱系上对细胞排序

```{r}
#读取上一步保存的CDS
#CDS <- readRDS("CDS_DDRTree.rds")
CDS <- orderCells(CDS)
```

### 第四步：作图

可以自己设置足够多的颜色。 图上的着色可以通过修改"color_by"参数, 这里的取值可以是`pData(CDS)`结果的列名。 点的大小可以通过`cell_size`修改

- 按照状态着色

```{r}
#先自定义足够多的颜色
my_colour <- c('#006dbb','#1cac55','#e52622','#4db3e8', "#c46cac", '#006dbb','#1cac55')
p1 <- plot_cell_trajectory(CDS, color_by = "State", cell_size = 1.25) +
  scale_colour_manual(values=my_colour)
p1

#保存到pdf文件
ggsave( "monocle_State.pdf")
```

- 按照聚类着色

```{r}
p2 <- plot_cell_trajectory(CDS, color_by = "majorCluster", cell_size = 1.25) +
  scale_colour_manual(values=my_colour) +
  theme(axis.ticks = element_blank(),axis.text = element_blank()) + #去掉刻度线
  guides(color = guide_legend(ncol = 2, title = NULL)) #图例分2列，不要图例的题目
p2

#保存到pdf文件
ggsave( "monocle_majorCluster.pdf", width = 5, height = 5)
```

```{r}
sessionInfo()
```
