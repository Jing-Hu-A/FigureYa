---
title: "FigureYa58 lncRNAreannotation"
author: "小丫画图出品"
date: "2018-12-9"
output: html_document
---
微信ID: epigenomics  E-mail: figureya@126.com

作者：biotrainee tang

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

对GEO的芯片进行lncRNA的重新注释，提取芯片中lncRNA的表达量。

![](example.png)

出自：<https://www.nature.com/articles/nsmb.2591>

## 应用场景

场景一：还没想好要研究哪个lncRNA，想像例文那样从诸多的芯片数据中找到靠谱的lncRNA。

场景二：我想看我研究的lncRNA的表达谱是怎样的，跟上下游基因的相关性如何。于是，找到一套我感兴趣的疾病的芯片数据，可惜芯片注释很古老，即使里面有lncRNA对应的探针，也无法直接拿到表达量。这时，就需要给芯片探针做重注释，标出芯片探针跟最新版本基因组注释之间的对应关系，进而拿到感兴趣的lncRNA的表达量。

同样适用于蛋白编码基因、miRNA芯片等。

如果你不想做重注释，而是要用官方的芯片注释提取lncRNA/miRNA/mRNA的表达矩阵，就用`FigureYa41GEO2lncRNA`

## 参数设置

```{r}
platformID <- "GPL15314" #要重注释的芯片平台
alignMethod <- "seqmap" #用seqmap作序列比对
#alignMethod <- "blast" #用blast作序列比对
np <- 4 #lncRNAs with at least 4 probes
```

这里提供两种序列比对的方法，结果相近，根据硬件条件任选其一：

1. blast，经典，功能齐全而细腻，输出多种score，可以用score进一步筛选，

缺点：速度慢。用了2个核，只比对前100条探针序列，用掉10s。全部探针的序列比对，14核，< 30 min。

2. seqman，速度超级快。8G内存，芯片上全部60315条探针的序列比对，< 1 min。（只比对前100条所用的时间也差不多）

缺点：不输出各种score，只有一个num_mismatch。

## 环境设置

**Windows系统：**见压缩包中的word文档。

**Linux和Mac：**

下载blast：<ftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/>

解压缩，把`makeblastdb`和`blastn`拷贝到当前文件夹

下载seqman：<http://www-personal.umich.edu/~jianghui/seqmap/>的全平台**source版本**：<http://www-personal.umich.edu/~jianghui/seqmap/download/seqmap-1.0.13-src.zip>

解压缩，然后在终端运行以下代码来编译，会生成一个seqman文件：

```bash
cd seqmap-1.0.13-src
make
```

然后把`seqman`文件拷贝到当前文件夹

```{r, message=FALSE}
#使用国内镜像安装包
#options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
#options(BioC_mirror="http://mirrors.ustc.edu.cn/bioc/")
if(! require('tidyverse')) install.packages('tidyverse')
if(! require('GEOquery')) install.packages('GEOquery')

library(tidyverse)
library(GEOquery)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

## 芯片重注释

### 输入文件

重注释需要最新转录本的DNA序列文件和芯片上探针的序列。

- 转录本DNA序列。以人为例，从gencode网站下载v29版本的转录本fasta文件：<ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_29/gencode.v29.transcripts.fa.gz>，解压缩到当前文件夹。已包含gene symbol、biotype等信息。

- 芯片探针的序列：

```{r}
if(!file.exists("GPL15314.soft")){
  gpl <- getGEO(platformID, destdir=".") #保存到本地
}
gpl <- getGEO(filename = "GPL15314.soft") #读取保存在当前文件夹的平台文件
gpl <- Table(gpl)
head(gpl)
```

像GPL15314平台，有SEQUENCE，就用下面这段：

```{r}
gpl <- gpl[,c(1,8)] #只保留探针ID和序列
gp <- dplyr::filter(gpl,!is.na(SEQUENCE))
length(unique(gp$SEQUENCE))

#保存为fasta格式文件
gp <- paste0('>',gp$ID,'\n', gp$SEQUENCE)
#为了测试blast，只保存前100行
#write.table(gp[1:100],'GPL.fasta', quote = F, row.names = F, col.names = F)
#保存全部序列，运行下面这行：
write.table(gp,'GPL.fasta', quote = F, row.names = F, col.names = F)
```
GPL没有提供Affymetrix芯片的SEQUENCE序列。如果你需要下载affy的芯片的fasta文件，大概率会在这个页面<http://www.affymetrix.com/support/technical/byproduct.affx?cat=arrays&Human#Human>，点击你的芯片名字，进去找文件名里带probeset或target字样的文件，免费注册，登录后下载。

- 例如GPL3921平台，直接到官网找到芯片平台页面：<http://www.affymetrix.com/support/technical/byproduct.affx?product=hgu133-20>，下载probeset的fasta文件：<http://www.affymetrix.com/Auth/analysis/downloads/data/HG-U133A_2.target.zip>

![](Affy_GPL3921.png)

- 例文用到的GPL5188平台，官网芯片平台页面：<http://www.affymetrix.com/support/technical/byproduct.affx?product=huexon-st>，下载probeset的fasta文件：<http://www.affymetrix.com/Auth/analysis/downloads/data/HuEx-1_0-st-v2.hg18.probeset.fa.zip>

![](Affy_GPL5188.png)



### 序列比对

例文要求：no mismatch

```{r}
if (alignMethod == "blast"){
  #建立比对索引库，也可以自己通过ncbi官方的脚本下载索引库
  system('./makeblastdb -in gencode.v29.transcripts.fa -dbtype nucl')
  
  #序列比对
  system('./blastn -db gencode.v29.transcripts.fa -query GPL.fasta -out blast_gene.tmp -outfmt 6 -task blastn-short -num_threads 2 -num_alignments 1 -evalue 1e-10')
  #会生成gplTOgene.txt文件
  
} else if (alignMethod == "seqmap") {
  #Windows的用法参考压缩包中的word文档
  #Linux or MAC
  system('./seqmap 0 GPL.fasta gencode.v29.transcripts.fa seqmap_gene.tmp /output_all_matches')
  
} else{
  stop("Unsupport mode")
}
```

**seqmap参数说明：**

- 0代表匹配探针错误个数0
- GPL.fasta 需要比对的探针序列
- 0 gencode.v29.transcripts.fa 转录本的fasta文件
- seqmap_gene.txt 输出文件
- //为输出全部匹配信息。

**顺序不可错误**

**注意：**在git bash中//代表/。

### 把探针ID跟基因、biotype对应起来

用到上面生成的序列比对结果，格式：

- `blast_gene.tmp`：探针ID在第1列，gene symbol、biotype都储存在第2列

- `seqmap_gene.tmp`：探针ID在第4列，gene symbol、biotype都储存在第1列

```{r}
if (alignMethod == "blast"){
  gplTOgene <- read_delim('blast_gene.tmp',delim = '\t',col_names = F)
  gplTOgene <- gplTOgene[,1:2]
  gplTOgene$gsym <- unlist(lapply(gplTOgene$X2,function(x) strsplit(as.character(x),"\\|")[[1]][6]))
  gplTOgene$biotype <- unlist(lapply(gplTOgene$X2,function(x) X = strsplit(as.character(x),"\\|")[[1]][8]))
  gplTOgene$gsym_biotype <- paste(gplTOgene$gsym,gplTOgene$biotype,sep = '|')
  
  #输出三列，探针ID、gene symbol、biotype
  gplTOgene <- gplTOgene[,c(1,3,4)]
  #输出两列，其中gene symbol和biotype合为一列
  #gplTOgene <- gplTOgene[,c(1,5)]
  colnames(gplTOgene)[1] <- 'ID'
  write_csv(gplTOgene,'gplTOgene.csv')
  
} else if (alignMethod == "seqmap") {
  gplTOgene <- read_delim('seqmap_gene.tmp',delim = '\t')
  gplTOgene <- gplTOgene[,c(1,4)]
  gplTOgene$gsym <- unlist(lapply(gplTOgene$trans_id,function(x) strsplit(as.character(x),"\\|")[[1]][6]))
  gplTOgene$biotype <- unlist(lapply(gplTOgene$trans_id,function(x) strsplit(as.character(x),"\\|")[[1]][8]))
  gplTOgene$gsym_biotype <- paste(gplTOgene$gsym,gplTOgene$biotype,sep = '|')
  #输出三列，探针ID、gene symbol、biotype
  gplTOgene <- gplTOgene[,c(2:4)]
  #输出两列，其中gene symbol和biotype合为一列
  #gplTOgene <- gplTOgene[,c(2,5)]

  gplTOgene <- distinct(gplTOgene)
  write_csv(gplTOgene,'gplTOgene.csv')
  
} else {
  stop("Unsupport mode")
}
```

### 提取lncRNA对应的探针

对lncRNA的定义，可参考Vega的标准：
<http://vega.archive.ensembl.org/info/about/gene_and_transcript_types.html>

例文要求：

1. removed all probes that were mapped to protein-coding transcripts and pseudogene transcripts

2. with at least 4 probes

```{r}
gplTOgene <- read.csv("gplTOgene.csv")

#根据实际研究目的，调整定义为lncRNA的gene_biotype，此处根据Vega，定义如下8种biotype为lncRNA
lncRNA <- paste("non_coding","3prime_overlapping_ncRNA","antisense","lincRNA","sense_intronic","sense_overlapping","macro_lncRNA","bidirectional_promoter_lncRNA",sep = "|")

#根据实际研究目的，调整定义为protein-coding transcripts and pseudogene transcripts的gene_biotype
protein_pseudo <- paste("IG_C_pseudogene","IG_V_pseudogene","polymorphic_pseudogene","processed_pseudogene","protein_coding","pseudogene","TR_V_pseudogene","transcribed_processed_pseudogene","transcribed_unitary_pseudogene","transcribed_unprocessed_pseudogene", "translated_processed_pseudogene","unitary_pseudogene","unprocessed_pseudogene",sep = "|")

#提取lncRNA对应的探针
lncRNA.probe0 <- gplTOgene[grepl(lncRNA, gplTOgene$biotype),]
dim(lncRNA.probe0)

#提取protein-coding transcripts and pseudogene transcripts对应的探针
protein_pseudo.probe <- gplTOgene[grepl(protein_pseudo, gplTOgene$biotype),]
dim(protein_pseudo.probe)

#removed all probes that were mapped to protein-coding transcripts and pseudogene transcripts
lncRNA.probe1 <- lncRNA.probe0[!(lncRNA.probe0$probe_id %in% protein_pseudo.probe$probe_id),]
dim(lncRNA.probe1)

#只保留unique mapping到1个lncRNA的探针，不要那些mapping到多个lncRNA的探针
uni <- names(table(lncRNA.probe1$probe_id)[table(lncRNA.probe1$probe_id) == 1])
lncRNA.probe2 <- lncRNA.probe1[match(uni,lncRNA.probe1$probe_id),]
dim(lncRNA.probe2)

#lncRNAs with at least 4 probes
nProbes <- names(table(lncRNA.probe2$gsym)[table(lncRNA.probe2$gsym) >= np])
lncRNA.probe3 <- lncRNA.probe2[lncRNA.probe2$gsym %in% nProbes,]
lncRNA.probe4 <- lncRNA.probe3[order(lncRNA.probe3$gsym),]
dim(lncRNA.probe4)

write.table(lncRNA.probe4,"lncRNA.probes.txt", quote = F,row.names = F, col.names = T)
```

## 提取lncRNA的表达量

输入文件：

- 'lncRNA.probes.txt'：lncRNA对应的探针。可用于提取同一平台芯片数据里的lncRNA表达量。

- 'easy_input.csv'：芯片探针的表达矩阵，第一列是探针ID，后面每列一个sample。从这里提取lncRNA的表达量。

```{r, warning=FALSE}
expr <- read.csv("easy_input.csv", header = T)
head(expr)

lncRNA.probe4 <- read.table("lncRNA.probes.txt", header = T)
head(lncRNA.probe4)

lncRNA.probe.expr <- merge(lncRNA.probe4[,1:2], expr, by = "probe_id")
row.names(lncRNA.probe.expr) <- lncRNA.probe.expr$probe_id
lncRNA.probe.expr$probe_id <- NULL
head(lncRNA.probe.expr)

# combine probe sets with same gene symbol
lncRNA.expr_uniq <- aggregate(.~gsym, lncRNA.probe.expr, median)
# set gene symbol as rowname
rownames(lncRNA.expr_uniq) <- lncRNA.expr_uniq$gsym
head(lncRNA.expr_uniq)
lncRNA.expr_uniq$gsym <- NULL
head(lncRNA.expr_uniq)

write.csv(lncRNA.probe.expr, "lncRNA_expr.csv", quote = F, row.names = F)
```

## 参考资料

- Blast 命令参数大全，官方说明文档：<https://www.ncbi.nlm.nih.gov/books/NBK279690/pdf/Bookshelf_NBK279690.pdf>

- Blast 快速入门，参考：<https://www.jianshu.com/p/de28be1a3bea>，<http://www.bioinfo-scrounger.com/archives/77>，<https://www.plob.org/article/4326.html>

- seqmap（全平台）官方说明文档：<http://www-personal.umich.edu/~jianghui/seqmap/Docs.txt>，FAQ<http://www-personal.umich.edu/~jianghui/seqmap/FAQ.html>

此外，Dianmond（linux mac）等软件也可以完成序列比对。

```{r}
sessionInfo()
```