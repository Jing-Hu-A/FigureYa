---
title: "FigureYa42oncoprintV2_update"
author: "小丫画图出品"
date: "2020-2-18"
output: html_document
---
欢迎关注“小丫画图”公众号，回复“小白”，看小视频，实现点鼠标跑代码。

微信ID: epigenomics  E-mail: figureya@126.com

原作者：小丫

更新者：Byron

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

没有具体突变位点信息，只有临床信息和突变名称，对应着每个个体，01矩阵，需要画这样的oncoprint图，按照pathway分开。

![](example1.png)

或者这种

![](example2.png)
出自<https://www.nejm.org/doi/full/10.1056/NEJMoa1301689>

# 应用场景

展示多个样本中多个基因的变异，以及临床信息。

- 场景一：01矩阵代表的一种变异类型。例如从基因检测报告中收集的变异基因。

- 场景二：多种变异类型，外显子测序数据。例如用FigureYa18oncoplot输出变异和临床信息，然后用本套代码修改成自己想要的效果。

If you use it in published research, please cite:

Gu, Z. Complex heatmaps reveal patterns and correlations in multidimensional genomic data. Bioinformatics 2016.

# 环境设置

使用国内镜像安装包

```{r}
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")
```

加载包

```{r}
library(ComplexHeatmap)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

# 场景一：01矩阵代表的一种变异类型

## 生成输入文件

这一步仅用于产生示例数据。可跳过这步，直接进入“输入文件”。

此处借用FigureYa18oncoplot的输出文件`onco_matrix.txt`，整理成小伙伴常用的**01矩阵**。

```{r}
onco_matrix <- read.table("onco_matrix.txt", header = T, row.names = 1, sep = "\t", as.is = T)
#查看部分数据格式
onco_matrix[1:3,1:4]

#把"Missense_Mutation"和"Sense_Mutation"替换为1，其他替换为0
onco_matrix[onco_matrix == "Missense_Mutation"] <- "1"
onco_matrix[onco_matrix == "Sense_Mutation"] <- "1"
onco_matrix[onco_matrix != "1"] <- "0"

write.csv(onco_matrix, "easy_input.csv", quote = F)
```

## 输入文件

`easy_input.csv`，01矩阵，每行一个基因，每列一个sample。01矩阵代表基因在这个sample里是否变异。

`easy_input_pathway.txt`，基因所在的pathway；

`easy_input_cli.csv`，临床信息，例如人种、病史、治疗方式等。

不同文件之间，基因名、sampleID必须一致。

```{r}
#读取基因变异数据
mygene <- read.csv("easy_input.csv", header = T,row.names = 1, as.is = T)
#查看部分数据的格式
mygene[1:3,1:4]
#用"mut"替换1，用""替换0
mygene[mygene == 1] <- "mut"
mygene[mygene == 0] <- ""

#读取基因所在的pathway
mypathway <- read.csv("easy_input_pathway.csv", header = T, row.names = 1, as.is = T)
head(mypathway)
#把pathway添加到mygene的最后一列
mygene$pathway <- mypathway[as.character(rownames(mygene)),]

#读取临床信息
mytype <- read.csv("easy_input_cli.csv")
head(mytype)
#查看有多少种临床信息类型
unique(mytype$type_A)
unique(mytype$type_B)
unique(mytype$type_C)
```

## 设置变异的颜色、形状

```{r}
#用fill = 设置mutation以及背景用什么颜色
alter_fun = list(
  background = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = NA, col = NA)) #不要背景色
  },
  mut = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = "#008000", col = NA)) #mut是绿色
  })

#mutation bar plot的颜色，跟瀑布图一致
col = c("mut" = "#008000")

#定义足够多的颜色
mycol <- c("#223D6C","#D20A13","#FFD121","#088247","#11AA4D","#58CDD9","#7A142C","#5D90BA","#431A3D","#91612D","#6E568C","#E0367A","#D8D155","#64495D","#7CC767")
```

## 从临床数据中删除没有变异的sample

参数`remove_empty_columns = TRUE`会删掉没有变异的sample，我们需要把临床数据中相应的sample也删掉。

**注意：**在后面所有画图命令中，column_order和remove_empty_columns这两个参数，都要跟p1的参数一致。

```{r,fig.width=10,highlight=4}
#提取瀑布图中画出的sample
p1 <- oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
                     alter_fun = alter_fun, col = col,
                     #remove_empty_columns = TRUE, #删除没有突变的sample
                     #column_order = NULL, #不按突变频率给sample排序
                     #row_order = NULL, #不按突变频率给基因排序
                     row_split = mygene$path)

matrix <- p1@matrix
sampleOrder <-  data.frame(p1@column_order)
rownames(sampleOrder) <- p1@column_names_param$labels
sampleOrder$oriOrder <- row.names(sampleOrder)
sampleOrder <- sampleOrder[order(as.numeric(sampleOrder[,1]),decreasing=F),]
rownames(mytype) <- mytype$sample

#在临床数据中，只保留瀑布图中画出的sample
mytype <- mytype[sampleOrder$oriOrder,]
```

现在，这个mytype就跟瀑布图中的sample一致了。

## 开始画图

把临床信息画在下面

```{r,fig.width=10,highlight=4}
#画临床数据的heatmap
my_annotation = HeatmapAnnotation(df = data.frame(mytype[2:4]),
                                  col = list(type_A = c("type1" = mycol[1], "type2" = mycol[2]),
                                             type_B = c("type3" = mycol[3], "type4" = mycol[4], "type5" = mycol[5]),
                                             type_C = c("type6" = mycol[6], "type7" = mycol[7], "type8" = mycol[8], "type9" = mycol[9])))

#画瀑布图
p <- oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
               alter_fun = alter_fun, col = col,
               #remove_empty_columns = TRUE,#删除没有突变的sample
               #column_order = NULL, #不按突变频率给sample排序
               #row_order = NULL, #不按突变频率给基因排序
               show_pct = FALSE, #左侧不显示百分比
               bottom_annotation = my_annotation,#把临床信息画在下面
               row_split = mygene$path, #按照pathway分开画
               show_heatmap_legend = FALSE) #不显示突变的图例
p

#保存到pdf文件
pdf("oncoprint_cli.pdf",width = 10,height = 5)
p
dev.off()
```

有人喜欢把临床数据画在上面

```{r,fig.width=12,highlight=4}
oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
          alter_fun = alter_fun, col = col,
          #remove_empty_columns = TRUE,
          #column_order = NULL, 
          #row_order = NULL, 
          #show_pct = FALSE, 
          top_annotation = my_annotation, #把临床信息画在上面
          row_split = mygene$path,
          show_heatmap_legend = FALSE)
```

还可以分开画两组临床信息，分别放在上面和下面

```{r,fig.width=10,highlight=4}
top_annotation = HeatmapAnnotation(df = data.frame(mytype[3]),
                                   col = list(type_B = c("type3" = mycol[3], "type4" = mycol[4], "type5" = mycol[5])),
                                   annotation_height = unit(0.2, "cm")) #临床信息heatmap的高度
bottom_annotation = HeatmapAnnotation(df = data.frame(mytype[c(2,4)]),
                                      col = list(type_A = c("type1" = mycol[1], "type2" = mycol[2]),
                                                 type_C = c("type6" = mycol[6], "type7" = mycol[7], "type8" = mycol[8], "type9" = mycol[9])))

p <- oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
         alter_fun = alter_fun, col = col,
         #remove_empty_columns = TRUE,
         #column_order = NULL, 
         #row_order = NULL, 
         show_pct = FALSE, 
         top_annotation = top_annotation,#上面的临床信息
         bottom_annotation = bottom_annotation,#下面的临床信息
         row_split = mygene$path,
         show_heatmap_legend = FALSE)
p

#保存到pdf文件
pdf("oncoprint_cli_nobar.pdf",width = 12,height = 5)
p
dev.off()
```

# 场景二：多种变异类型

## 输入文件

`onco_matrix.txt`，基因变异矩阵，此处以FigureYa18的输出文件作为输入；

`easy_input_pathway.txt`，基因所在的pathway；

`easy_input_cli.csv`，临床信息，例如人种、病史、治疗方式等。

```{r}
#读取基因变异数据
mygene <- read.table("onco_matrix.txt",header = T,row.names = 1,sep = "\t",as.is = T)
#查看部分数据的格式
mygene[1:3,1:3]

#查看一共有多少种变异类型
mygene_new <- as.matrix(mygene)
dim(mygene_new) <- c(ncol(mygene)*nrow(mygene),1)
unique(mygene_new)

#读取基因所在的pathway
mypathway <- read.csv("easy_input_pathway.csv", header = T, row.names = 1, as.is = T)
head(mypathway)

#把pathway添加到mygene的最后一列
mygene$pathway <- mypathway[as.character(rownames(mygene)),]

#读取临床信息
mytype <- read.csv("easy_input_cli.csv")
head(mytype)
```

## 设置变异的颜色、形状

```{r}
#先定义足够多的颜色
mycol <- c("#223D6C","#D20A13","#FFD121","#088247","#11AA4D","#58CDD9","#7A142C","#5D90BA","#431A3D","#91612D","#6E568C","#E0367A","#D8D155","#64495D","#7CC767")

#Multi_Hit为短矩形，其余为长矩形
alter_fun = list(
  background = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = NA, col = NA)) #不要背景色
  },
  Nonsense_Mutation = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[4], col = NA)) 
  },
  Missense_Mutation = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[5], col = NA)) 
  },
  Frame_Shift_Del = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[1], col = NA)) 
  },
  Frame_Shift_Ins = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[2], col = NA)) 
  },
  Splice_Site = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[6], col = NA)) 
  },
  In_Frame_Del = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[7], col = NA)) 
  },
  In_Frame_Ins = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h-unit(0.5, "mm"), gp = gpar(fill = mycol[8], col = NA)) 
  },
  Multi_Hit = function(x, y, w, h) {
    grid.rect(x, y, w-unit(0.5, "mm"), h*0.33, gp = gpar(fill = "black", col = NA)) 
  }
)

#bar plot的颜色，跟瀑布图一致
col = c("Nonsense_Mutation" = mycol[4], 
        "Missense_Mutation" = mycol[5], 
        "Frame_Shift_Del" = mycol[1], 
        "Frame_Shift_Ins" = mycol[2], 
        "Splice_Site" = mycol[6], 
        "In_Frame_Del" = mycol[7],
        "In_Frame_Ins" = mycol[8],
        "Multi_Hit" = "black")
```

## 从临床数据中删除没有变异的sample

```{r}
#提取瀑布图中画出的sample
p1 <- oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
                     alter_fun = alter_fun, col = col,
                     remove_empty_columns = TRUE, #删除没有突变的sample
                     #column_order = NULL, #不按突变频率给sample排序
                     #row_order = NULL, #不按突变频率给基因排序
                     row_split = mygene$path)

matrix <- p1@matrix
sampleOrder <-  data.frame(p1@column_order)
rownames(sampleOrder) <- p1@column_names_param$labels
sampleOrder$oriOrder <- row.names(sampleOrder)
sampleOrder <- sampleOrder[order(as.numeric(sampleOrder[,1]),decreasing=F),]
rownames(mytype) <- mytype$sample

#在临床数据中，只保留瀑布图中画出的sample
mytype <- mytype[sampleOrder$oriOrder,]
```

现在，这个mytype就跟瀑布图中的sample一致了。

## 开始画图

```{r, fig.width=12, fig.height=5}
#画临床数据的heatmap
my_annotation = HeatmapAnnotation(df = data.frame(mytype[2:4]),
                                  col = list(type_A = c("type1" = mycol[1], "type2" = mycol[2]),
                                             type_B = c("type3" = mycol[3], "type4" = mycol[4], "type5" = mycol[5]),
                                             type_C = c("type6" = mycol[6], "type7" = mycol[7], "type8" = mycol[8], "type9" = mycol[9])))

#画瀑布图
p <- oncoPrint(mygene[1:(ncol(mygene)-1)], get_type = function(x) x,
               alter_fun = alter_fun, col = col,
               remove_empty_columns = TRUE,
               #column_order = NULL, 
               #row_order = NULL, 
               show_pct = FALSE, 
               bottom_annotation = my_annotation,
               row_split = mygene$path)
p

#保存到pdf文件
pdf("oncoprint_cli_multi.pdf",width = 12,height = 5)
p
dev.off()
```

```{r}
sessionInfo()
```
