---
title: "FigureYa210survivalScape"
author: "小丫画图出品"
date: "2020-12-11"
output: html_document
---
欢迎关注“小丫画图”公众号，回复“小白”，看小视频，实现点鼠标跑代码。

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：中国药科大学国家天然药物重点实验室，生物统计与计算药学研究中心

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

用survdiff复现文章里的图，把所有基因的HR、pvalue输出到文件。

![](example.png)

出自<https://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3>

Fig. 3 Clinical relevance of m6A regulators across cancer types. a Summary of the correlation between expression of m6A regulators and patient survival. **Red** represents a higher expression of m6A regulator associated with **worse survival**, and **blue** represents an association with **better survival**. Only p values < 0.05 are shown. 

基于这一结果，下一步的做法：

- 例文分析每个m6A基因在pancancer和GEO多个数据集中的hazard ratios，画出森林图Fig. 3b The distribution of hazard ratios across different cancer types. 可参考FigureYa66单因素cox。
- 筛选获得显著影响生存的基因/癌症，然后批量画生存曲线，可参考FigureYa35batch_bestSeparation

我们还复现过这篇文章的Fig. 2A，用`FigureYa199crosslink`带你实现连线自由。

# 应用场景

场景一：像例文那样，用TCGA-pancancer表达数据计算某个基因集的survival landscape。

场景二：批量筛选。或许你可以计算基因组上所有基因的survival landscape，筛选出genes associated with the overall survival of patients (worse/better survival) in at least one cancer type或你关心的几种癌症或所有癌症。

这里提供cox和survdiff（logrank，中位数区分高低组）两种方式：

- 方法一：（推荐）用cox来说明protective和risky是比较合理的做法。
- 方法二：（需求者提出的）survdiff的logrank，对于输入FPKM和TPM都可以用。

结果的可视化。例文用红蓝白表示风险、保护和不显著。或许你想用颜色的深浅来展示具体的数值，或者用形状和颜色同时展示HR和pvalue，可参考的FigureYa97correlation画法。

# 环境设置

使用国内镜像安装包

```{r}
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")

```

加载包

```{r}
library(data.table)
library(survival)
library(pheatmap)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

# 输入文件的获得

需要表达矩阵和生存数据，如果你已经准备好easy_input_gene.txt、easy_input_expr.csv和easy_input_surv.csv文件，就可以跳过这步，直接进入“输入文件”。

- easy_input_gene.txt，例文中的m6A基因，用到`Symbol`列，将提取这些基因的表达矩阵。

- tcga_RSEM_gene_tpm和gencode.v23.annotation.gene.probemap，表达矩阵和Gene mapping，跟FigureYa208FPI的一样，微云链接：<https://share.weiyun.com/c8GQyxR4>。**建议自己动手，从xena网站下载**，下载方式：

  - 这里跟FigureYa55panCancer_violin保持一致，从[XENA](https://xenabrowser.net/datapages/)下载UCSC Toil RNA-seq Recompute TPM：[TCGA Pan-Cancer (PANCAN) (41 datasets)](https://xenabrowser.net/datapages/?cohort=TCGA%20Pan-Cancer%20(PANCAN)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443)里的[TOIL RSEM tpm (n=10,535) UCSC Toil RNA-seq Recompute](https://toil.xenahubs.net/download/tcga_rsem_isoform_tpm.gz)，[Gene Mapping](https://toil.xenahubs.net/download/probeMap/gencode.v23.annotation.transcript.probemap)

  - 或者下载GDC pipeline的FPKM-UQ：[GDC Pan-Cancer (PANCAN) (17 datasets)](https://xenabrowser.net/datapages/?cohort=GDC%20Pan-Cancer%20(PANCAN)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443) 里的[HTSeq - FPKM-UQ (n=11,768) GDC Hub](https://gdc.xenahubs.net/download/GDC-PANCAN.htseq_fpkm-uq.tsv.gz)，[Gene Mapping](https://gdc.xenahubs.net/download/gencode.v22.annotation.gene.probeMap)

- pancancerSurvivalData.txt，样本注释及生存信息，从[XENA](https://xenabrowser.net/datapages/)下载后整理而成。

  - 生存信息的下载方式：[Curated clinical data (n=12,591)](https://xenabrowser.net/datapages/?dataset=Survival_SupplementalTable_S1_20171025_xena_sp&host=https%3A%2F%2Fpancanatlas.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443)里的[Curated clinical data](https://pancanatlas.xenahubs.net/download/Survival_SupplementalTable_S1_20171025_xena_sp.gz)

  - 样本信息的下载方式：[TCGA Pan-Cancer (PANCAN) (41 datasets) phenotype](https://xenabrowser.net/datapages/?cohort=TCGA%20Pan-Cancer%20(PANCAN)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443)里的[sample type and primary disease (n=12,804) Pan-Cancer Atlas Hub](https://pancanatlas.xenahubs.net/download/TCGA_phenotype_denseDataOnlyDownload.tsv.gz)。

```{r eval=FALSE}
## 读取泛癌表达谱和注释文件
# 文件较大，占内存，请谨慎操作
panexpr <- fread("tcga_RSEM_gene_tpm",sep = "\t",header = T,check.names = F,stringsAsFactors = F)
annopb <- read.delim("gencode.v23.annotation.gene.probemap",row.names = 1,check.names = F,stringsAsFactors = F,header = T,sep = "\t")

# 匹配基因名
panexpr <- as.data.frame(panexpr)
rownames(panexpr) <- panexpr$sample; panexpr <- panexpr[,-1]
comgene <- intersect(rownames(annopb), rownames(panexpr))
panexpr <- panexpr[comgene,]; annopb <- annopb[comgene,]
panexpr$genename <- annopb$gene; panexpr <- panexpr[!duplicated(panexpr$genename),]
rownames(panexpr) <- panexpr$genename; panexpr <- panexpr[,-ncol(panexpr)]
panexpr[1:3,1:3]

## 读取目标基因及其所在的分组信息，用于最后画热图
gene_group <- read.table("easy_input_gene.txt",sep = "\t",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)
gene_group[which(gene_group$Symbol == "VIRMA"),"Symbol"] <- "KIAA1429" # 根据GeneCards，该基因替换同义名，否则在TCGA数据里查不到

# 提取目标基因的表达矩阵
panexpr <- panexpr[gene_group$Symbol,]
gc() # 释放内存

# 还原表达谱（以下步骤请根据自己表达谱的情况来）
panexpr <- 2^panexpr - 0.001 # 原始数据为log2(x+0.001)
panexpr[panexpr < 0] <- 0 # 小于0的值拉到0
# 重新对数化
panexpr <- log2(panexpr + 1) 

# 剔除表达量比较奇怪的基因，出自FigureYa35batch_bestSeparationV3_update
panexpr <- panexpr[,apply(panexpr, 1, sd) > 0] # 取方差大于1的基因

## 读取样本注释和生存信息
pansurv <- read.table("pancancerSurvivalData.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
rownames(pansurv) <- paste0(rownames(pansurv),"-01") # 创建原位癌barcode

# 取出例文癌症
tumors <- unique(pansurv$type) # 提取有生存信息的癌种
comsam <- intersect(colnames(panexpr),rownames(pansurv)) # 提取共享的样本
pansurv <- pansurv[comsam,]
panexpr <- panexpr[,comsam]
tumors <- unique(pansurv$type)

# 保存到文件，便于非TCGA数据套用格式
write.csv(pansurv, "easy_input_surv.csv", quote = F)
write.csv(panexpr, "easy_input_expr.csv", quote = F)
```

# 输入文件

跟FigureYa35batch_bestSeparation类似，都需要表达矩阵和生存信息。

另外，画热图时需要基因分组信息。

- easy_input_surv.csv，生存信息。每行一个sample，三列分别是sample分组（这里是cancer type）、OS、OS.time。
- easy_input_expr.csv，表达矩阵。每行一个基因，每列一个sample。
- easy_input_gene.txt，例文中的m6A基因，用到Symbol和Function两列。前面用`Symbol`列提取了表达矩阵；`Function`列作为分组在热图中用不同颜色显示出来，非必需。可以替换成你感兴趣的基因及其分组信息，例如某些特征基因所在的通路等。

```{r}
# 读取生存信息和样品分组
pansurv <- read.csv("easy_input_surv.csv", row.names = 1, check.names = F)
tumors <- unique(pansurv$type)
# 读取表达矩阵
panexpr <- read.csv("easy_input_expr.csv", row.names = 1, check.names = F)
# 读取目标基因及其分组，用于最后画热图
gene_group <- read.table("easy_input_gene.txt",sep = "\t",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)
# 根据GeneCards，该基因替换同义名，否则在TCGA数据里查不到
gene_group[which(gene_group$Symbol == "VIRMA"),"Symbol"] <- "KIAA1429" 
```

# 循环计算基因与癌症的预后关系

cox和logrank两种方式都计算出来

```{r}
# cox分析的数据初始化
survland.coxhr <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化cox分析HR结果
survland.coxp <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化cox分析p值结果
survland.coxplot <- matrix(0,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化绘图数据

# logrank分析的数据初始化
survland.logrankhr <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化logrank分析hr值结果
survland.logrankp <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化logrank分析p值结果
survland.logrankplot <- matrix(0,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化绘图数据

# 循环计算每一个癌症
for(t in tumors) {
  for (g in gene_group$Symbol) { # 循环计算每一个基因
    sam <- rownames(pansurv[which(pansurv$type == t),]) #提取当前癌症的sample ID
    expr <- as.numeric(panexpr[g,sam]) # 提取当前基因的表达量
    
    expr.surv <- data.frame(futime = pansurv[sam,"OS.time"], # 提取当前癌症的生存信息
                            fustat = pansurv[sam,"OS"], # 提取当前癌症的生存信息
                            expr = expr, # 基因表达量
                            stringsAsFactors = F)
    
    ## 方法一：cox
    cox <- coxph(Surv(futime,fustat) ~ expr, data = expr.surv) # cox分析
    coxSummary <- summary(cox)
    hr <- as.numeric(coxSummary$coefficients[,"exp(coef)"])[1] # 提出HR
    pvalue <- as.numeric(coxSummary$coefficients[,"Pr(>|z|)"])[1] # 提出p值
    survland.coxhr[g,t] <- hr
    survland.coxp[g,t] <- pvalue
    
    # 为画图准备矩阵
    if(pvalue < 0.05) { # 如果p值显著的话存储数据
      survland.coxplot[g,t] <- ifelse(hr > 1, 1, -1) # HR>1为风险因素，记为“1”，HR<1为保护因素，记为-1，其余默认为0
    }
    
    ## 方法二：logrank
    # 用中值（median）为样本分组，如果想用最佳分组，可参考FigureYa35batch_bestSeparationV3_update
    expr.surv$group = ifelse(expr > median(expr),"high","low")
    expr.surv$group <- factor(expr.surv$group, levels = c("low", "high"))
    
    data.survdiff <- survdiff(Surv(futime,fustat) ~ group, data = expr.surv)
    pvalue <- 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)
    hr <- (data.survdiff$obs[2]/data.survdiff$exp[2])/(data.survdiff$obs[1]/data.survdiff$exp[1])
    survland.logrankhr[g,t] <- hr
    survland.logrankp[g,t] <- pvalue
    
    # 为画图准备矩阵
    if(pvalue < 0.05) { # 如果p值显著的话存储数据
      survland.logrankplot[g,t] <- ifelse(hr > 1, 1, -1) # HR>1为风险因素，记为“1”，HR<1为保护因素，记为-1，其余默认为0
    }
  }
}

## 保存到文件，便于DIY其他形式的图
# 或者以更大范围的基因（例如全基因组）作为输入，然后用HR和pvalue筛选出genes associated with the overall survival of patients (worse/better survival) in at least one cancer type或你关心的几种癌症或所有癌症
# cox
write.table(survland.coxplot, file = "cox_genes associated with the OS.txt", sep = "\t", row.names = T, col.names = T, quote = F)
write.table(survland.coxhr,file = "cox HR in survival landscape.txt",sep = "\t",row.names = T,col.names = NA,quote = F)
write.table(survland.coxp,file = "cox pvalue in survival landscape.txt",sep = "\t",row.names = T,col.names = NA,quote = F)

# logrank
write.table(survland.logrankplot, file = "logrank_genes associated with the OS.txt", sep = "\t", row.names = T, col.names = T, quote = F)
write.table(survland.logrankhr,file = "logrank HR in survival landscape.txt",sep = "\t",row.names = T,col.names = NA,quote = F)
write.table(survland.logrankp,file = "logrank pvalue in survival landscape.txt",sep = "\t",row.names = T,col.names = NA,quote = F)
```

# 开始画图

用pheatmap分别画出cox和logrank的结果。

```{r}
# 自定义颜色
red <- "#D02E20"
blue <- "#4D76B7"
green <- "#50B544"
yellow <- "#F8C77A"
cyan <- "#5AC8F9"

annRow <- gene_group # 行基因注释
rownames(annRow) <- annRow$Symbol
annColors <- list("Function" = c("Readers" = green,
                                 "Writers" = yellow,
                                 "Eraser" = cyan))

# cox
pheatmap(survland.coxplot,
         border_color = "grey50",
         show_rownames = T, # 显示行名
         show_colnames = T, # 显示列明
         cluster_rows = F, # 行不聚类
         cluster_cols = F, # 列不聚类
         color = c(blue,"grey95",red),
         annotation_row = annRow[,"Function",drop = F],
         annotation_colors = annColors,
         legend_breaks = c(-1,0,1), # 修改图例的显示位置
         legend_labels = c("Protective","p>0.05","Risky"), # 修改图例标签
         cellwidth = 10, # 单元格宽度
         cellheight = 10, # 单元格高度
         filename = "m6A survival landscape using cox.pdf", # 保存文件
         width = 8, # 图片宽度
         height = 6) # 图片高度

# logrank
pheatmap(survland.logrankplot,
         border_color = "grey50",
         show_rownames = T, # 显示行名
         show_colnames = T, # 显示列明
         cluster_rows = F, # 行不聚类
         cluster_cols = F, # 列不聚类
         color = c(blue,"grey95",red),
         annotation_row = annRow[,"Function",drop = F],
         annotation_colors = annColors,
         legend_breaks = c(-1,0,1), # 修改图例的显示位置
         legend_labels = c("Protective","p>0.05","Risky"), # 修改图例标签
         cellwidth = 10, # 单元格宽度
         cellheight = 10, # 单元格高度
         filename = "m6A survival landscape using logrank.pdf", # 保存文件
         width = 8, # 图片宽度
         height = 6) # 图片高度
```

![](m6A survival landscape using cox.pdf)

![](m6A survival landscape using logrank.pdf)

# Session Info

```{r}
sessionInfo()
```