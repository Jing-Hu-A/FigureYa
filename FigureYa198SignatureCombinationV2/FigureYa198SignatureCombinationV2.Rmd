---
title: "FigureYa198SignatureCombinationV2"
author: "小丫画图出品"
date: "2020-10-21"
output: html_document
---
欢迎关注“小丫画图”公众号，回复“小白”，看小视频，实现点鼠标跑代码。

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：中国药科大学国家天然药物重点实验室，生物统计与计算药学研究中心

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

我想众筹下文章figure 1c的计算方法，FigureYa182RFSurv挑出了importance 比较大的基因，后续常规用muticox等方法再缩减基因。这篇文章写的是用1023中组合按KM的 logRank pvalue和基因数目挑选模型，不一样的风格。

![](example.png)

出自<https://onlinelibrary.wiley.com/doi/abs/10.1002/jcp.28600>

FIGURE 1 Identification of candidate genes and development of an integrated PCG‐lncRNA signature. (a) Volcano plot displayed the lncRNAs and PCGs of the univariate Cox regression analysis. (b) Random survival forest analysis screened 10 genes. (c) After Kaplan–Meier analysis of 2 ‒1 = 1,023 combinations, the top 20 signatures were sorted according to the p value of KM. And the signature included five genes that were screened out, for it had a relative big −log10 p value and a small number of genes. KM: Kaplan–Meier; lncRNA: long noncoding RNA; PCG: protein‐coding gene

# 应用场景

核心就是排列组合。

根据随机生存森林分析筛选变量，通过基因组合后利用log-rank检验取p值显著且基因个数较少的组合，定义为预后签名。

# 环境设置

使用国内镜像安装包

```{r eval=FALSE}
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")
install.packages("randomForestSRC")
```

加载包

```{r}
library(survival)
library(randomForestSRC)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

自定义函数

```{r}
# 显示进程
display.progress = function (index, totalN, breakN=20) {
  if ( index %% ceiling(totalN/breakN) == 0  ) {
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
}  
```

# 输入文件

brca.mRNA.expr.txt和brca.lncRNA.expr.txt，基因表达矩阵。

brca.surv.txt，临床信息。

原文只有99个样本。我们这里有180个样本。

![](method.PNG)

```{r}
# 加载表达数据
mexp <- read.table("brca.mRNA.expr.txt",sep = "\t",header = T,row.names = 1,check.names = F,stringsAsFactors = F)
lexp <- read.table("brca.lncRNA.expr.txt",sep = "\t",header = T,row.names = 1,check.names = F,stringsAsFactors = F)
surv <- read.table("brca.surv.txt",sep = "\t",header = T,row.names = 1,check.names = F,stringsAsFactors = F)

# 提取既有表达数据又有临床数据的样本
com_sam <- intersect(intersect(colnames(mexp),rownames(surv)),colnames(lexp))
mexp <- mexp[,com_sam]
lexp <- lexp[,com_sam]
surv <- surv[com_sam,]

# 合并表达谱
expr <- rbind.data.frame(mexp,lexp)

# 去除无表达的基因，log变换，z-score
expr <- expr[rowSums(expr) > 0,]
expr <- as.data.frame(round(t(scale(t(log2(expr + 1)))),3))
```

# 过滤出与OS有关的基因

```{r}
cox.pcutoff <- 0.05 # cox的p阈值
Coxoutput.OS <- NULL
for (i in 1:nrow(expr)) {
  display.progress(index = i,totalN = nrow(expr)) # 显示进度
  
  # 产生临时变量存储生存以及变量表达值
  tmp <- data.frame(gene = as.numeric(expr[i,]),
                    OS.time = surv[,"OS.time"],
                    OS = surv[,"OS"],
                    stringsAsFactors = F)
  
  # 单变量cox比例风险模型
  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)
  coxSummary = summary(cox)
  
  # 生成cox结果数据框，包括基因名，风险比，z值，waldtest p值，以及HR置信区间
  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(expr)[i],
                                                        HR=as.numeric(coxSummary$coefficients[,"exp(coef)"]),
                                                        z=as.numeric(coxSummary$coefficients[,"z"]),
                                                        pvalue=as.numeric(coxSummary$coefficients[,"Pr(>|z|)"]),
                                                        lower=as.numeric(coxSummary$conf.int[,3]),
                                                        upper=as.numeric(coxSummary$conf.int[,4]),
                                                        stringsAsFactors = F),
                                stringsAsFactors = F)
}
head(Coxoutput.OS)
write.csv(Coxoutput.OS,"univariate cox regression for gene filtering.csv",row.names = F,quote = F)
```

# 随机森林进一步降维

```{r}
gene.sel <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),"gene"]
tmp <- expr[gene.sel,]

rownames(tmp) <- gsub("-","_",rownames(tmp)) # 防止出现“-”导致程序报错
dt.rf <- cbind.data.frame(surv[,c("OS","OS.time")],t(tmp))

ntree <- 1000
surv.rf <- rfsrc(Surv(OS.time, OS) ~ ., 
                 data = dt.rf, 
                 ntree = ntree,
                 importance = TRUE,
                 seed = 12345678)
```

# 排列组合确定最优签名

```{r}
num.imp <- 10
rel.imp <- sort(surv.rf$importance, decreasing = T)
rel.imp.sel <- rel.imp[1:num.imp] # 取出一定数量的基因
names(rel.imp.sel) <- gsub("_","-",names(rel.imp.sel)) # 还原基因名

outTab <- NULL
n.sum <- 0
for (i in 1:num.imp) {
  cat(paste0("combination using ",i," genes...\n"))
  tmp <- utils::combn(names(rel.imp.sel), m=i) # 获取当前基因个数下的排列组合
  n <- ncol(tmp)
  for (j in 1:n) {
    combgene <- tmp[,j] # 取出每一次组合的基因名
    combexpr <- cbind.data.frame(t(expr[combgene,]), # 构建数据库做多变量cox
                                 OS.time = surv[,"OS.time"],
                                 OS = surv[,"OS"],
                                 stringsAsFactors = F)
    cox <- coxph(Surv(OS.time, OS) ~ ., data = combexpr)
    coxSummary <- summary(cox)
    coeff <- coxSummary$coefficients[,1] # 取出系数
    riskscore <- as.matrix(combexpr[,combgene]) %*% coeff # 计算riskscore
    riskscore <- data.frame(riskscore = as.numeric(riskscore[,1]),
                            group = ifelse(riskscore[,1] > median(riskscore[,1]),"HRisk","LRisk"), # 根据中位数分组
                            row.names = rownames(riskscore),
                            OS.time = combexpr$OS.time,
                            OS = combexpr$OS,
                            stringsAsFactors = F)
    fitd <- survdiff(Surv(OS.time, OS) ~ group,
                     data = riskscore,
                     na.action = na.exclude)
    p.val <- 1-pchisq(fitd$chisq, length(fitd$n) - 1) # log-rank检验
    
    outTab <- rbind.data.frame(outTab,
                               data.frame(num.gene = ifelse(i == 1, paste0(i," gene"), paste0(i," genes")), # 当前基因数目
                                          km.pvalue = p.val, # KM曲线p值
                                          core.gene = paste(combgene,collapse = " | "), # 该组合下的基因
                                          stringsAsFactors = F),
                               stringsAsFactors = F)
  }
  n.sum <- n + n.sum # 校验排列组合的总数
}
if(n.sum == 2^num.imp-1) { # 如果总和不等则报错
  write.csv(outTab,"combination of important genes with KM pvalues.csv",row.names = F,quote = F)
} else (message("Wrong combination!!!"))
```

# 开始画图

## 绘制火山图

```{r}
sigpoints <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),]
unsigpoints <- Coxoutput.OS[which(Coxoutput.OS$pvalue >= cox.pcutoff),]

pdf("volcano.pdf",width = 5,height = 5)
par(bty = "o", mgp = c(2,.6,0), mar = c(3,3,1,1), las = 1, font.axis = 1) # 基础参数
plot(log(Coxoutput.OS$HR),
     -log10(Coxoutput.OS$pvalue),
     xlab = "Univariate Cox coefficient",
     ylab = bquote("-log"[10]~"(P value)"),
     xlim = c(-2,2))
points(log(sigpoints$HR),
       -log10(sigpoints$pvalue),
       col = ggplot2::alpha("#E53435",0.8),
       pch = 19)
points(log(unsigpoints$HR),
       -log10(unsigpoints$pvalue),
       col = ggplot2::alpha("#21498D",0.8),
       pch = 19)
abline(h = -log10(cox.pcutoff), lty = 2, col = "grey60")
invisible(dev.off())
```

![](volcano.pdf)

## 重要性图

```{r}
xrange <- range(pretty(range(rel.imp.sel))) # 根据重要性区间确定x轴范围
yrange <- c(1,length(rel.imp.sel))  # 根据重要变量个数确定y轴范围

pdf("variable importance.pdf",width = 5,height = 5)
par(bty = "o", mgp = c(1.5,.33,0), mar = c(3,7,1,2),las = 1, tcl = -.25)
plot(NULL,NULL,
     xlim = xrange,
     ylim = yrange,
     xlab = "Variable Importance",
     ylab = "",
     yaxt = "n",
     las = 1)
axis(side = 2,at = 1:length(rel.imp.sel),rev(names(rel.imp.sel))) # 补齐y轴
for (i in 1:length(rel.imp.sel)) { # 循环添加线
  lines(c(xrange[1],rev(rel.imp.sel)[i]),
        c(i,i),
        lwd = 2.5,
        col = "steelblue")
}
invisible(dev.off())
```

![](variable importance.pdf)

## 绘制排列组合p值

```{r}
num.comb <- 20
outTab2 <- outTab[order(outTab$km.pvalue),][1:num.comb,]

pdf("combination barplot.pdf",width = 5,height = 5)
par(bty = "o", mgp = c(1.5,.33,0), mar = c(1,4,3,1),las = 1, tcl = -.25)
barplot(rev(-log10(outTab2$km.pvalue)),
        horiz = T, # 柱状图横向
        names.arg = rev(outTab2$num.gene), # 添加y轴名称
        xaxt = "n", # 取消下方x轴
        col = "#E53435")
axis(side = 3) # 在上方添加x轴
mtext(side = 3, bquote("-log"[10]~"(P value)"), line = 1) # 添加x轴名称
invisible(dev.off())
```

![](combination barplot.pdf)

# Session Info

```{r}
sessionInfo()
```