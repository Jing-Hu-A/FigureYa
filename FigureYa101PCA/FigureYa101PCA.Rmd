---
title: "FigureYa101PCA"
author: "小丫画图出品"
date: "2019-5-31"
output: html_document
---
欢迎关注“小丫画图”公众号，同名知识星球等你加入

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：Research Center of Biostatistics and Computational Pharmacy, China Pharmaceutical University

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 需求描述

RNA-seq的PCA图，同一组用相同颜色，多次重复（批次）用不同形状。我的分组很多，3次重复，不需要像FigureYa38PCA那样画圈画箭头。

![](example.png)

出自<http://genesdev.cshlp.org/content/32/2/96>

## 应用场景

场景一：每个分组内的样品较多，是不同批次获得的。如果能用各种形状来区分批次的话，就能一眼看出哪个批次远离其他批次，有助于判断批次效应的影响。

场景二：每个分组内的样品是2到n次生物学重复获得的。如果能用各种形状来区分不同重复的话，就能一眼看出哪次重复远离其他重复，有助于判断去掉哪个离群样品。

如果想画圈和箭头，或者无法提供重复或批次batch的信息，请使用FigureYa38PCA。

不仅限于RNA-seq，同样适用于其他类型的数据。

## 环境设置

```{r}
library(stringr)
Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

## 自定义函数

包括PCA分析过程以及出图，参数设置：

- indata 是一个矩阵，列为样本，行为观测
- batch 是一个数据框，必须提供批次的信息，否则请使用FigureYa38PCA
- batchvar 是批次的变量名，这里默认batch的列名
- position 是最后出图时图例的位置，从以下位置中选择："bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right" and "center". 
- pch.original 是用于映射replicate形状的，默认从pch=16实心原点开始，到pch=25，一共10种实心图案可供映射，也可以自己选择pch形状起始点，参考：http://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r
- withoutgrid 是一个逻辑变量，指示是否要绘制背景网格（例文的图有网格，个人不推荐）
- 如果想输出样本ID，可以将showID设为TRUE，但样本量大的时候不推荐，图会看不清楚
- 其他参数可保持默认
- 函数细节可根据需要自己修改，比如batch的形状（pch参数）
 
```{r}
pca2batch <- function(indata, batch, batchvar = colnames(batch), fig.dir, PCA.fig.title, pos1 = "bottomright", pos2 = "topright", xy=c(1,2), pch.orginal=16, cols=NULL, showID=FALSE, cex=1, showLegend=T, batch1move=0.3, batch2move=0.4, width=5, height=5, withoutgrid=TRUE) {
 
  library(ClassDiscovery) #加载需要的包
  
  N.batch1 = length(unique(batch[,batchvar[1]]))    
  N.batch2 = length(unique(batch[,batchvar[2]]))    
  
  if (is.null(cols)) { #是否存在自定义颜色
    cols <- rainbow(N.batch1) 
  }else{
    if (length(cols) != N.batch1) {stop("cols length not equal to batch length")} #若颜色不匹配则报错
  }           
  
  indata=na.omit(indata)
  pca <- SamplePCA(indata, usecor=F, center=F) # 这里不做标准化，建议在输入数据的时候根据需求提前标准化
  pct1 <- round (pca@variances[xy[1]]/sum(pca@variances), digits=3)*100 # 计算第一个主成份占比
  pct2 <- round (pca@variances[xy[2]]/sum(pca@variances), digits=3)*100 # 计算第二个主成份占比
  xlab.text = paste("PC", xy[1], ": ", as.character(pct1), "% variance", sep="")
  ylab.text = paste("PC", xy[2], ": ", as.character(pct2), "% variance", sep="")
  
  if(withoutgrid) {
    outfile = file.path(fig.dir, paste(PCA.fig.title, ".withoutgrid.pdf",sep="")) #设置输出图片的名称
    
    pdf(file=outfile, width = width, height = height)
    par(mar = par()$mar + c(0,0,0,6)) #在右侧留出画图例的地方
    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], 
         cex=cex, xlab=xlab.text, ylab=ylab.text,
         col=cols[factor(batch[,batchvar[1]])], 
         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])
    abline(h=0, v=0, col="brown", lty=2)
  } else {
    outfile = file.path(fig.dir, paste(PCA.fig.title, ".withgrid.pdf",sep="")) #设置输出图片的名称
    
    #保存到PDF文件
    pdf(file=outfile, width = width, height = height)
    par(mar = par()$mar + c(0,0,0,6)) #在右侧留出画图例的地方
    #先绘制一次固定视窗
    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], 
         cex=cex, xlab=xlab.text, ylab=ylab.text,
         col=cols[factor(batch[,batchvar[1]])], 
         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])
    rect(par("usr")[1],par("usr")[3],par("usr")[2],par("usr")[4],col = "gray80") #产生灰色背景
    
    #再画一次覆盖灰色
    par(new=TRUE)
    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], 
         cex=cex, xlab=xlab.text, ylab=ylab.text,
         col=cols[factor(batch[,batchvar[1]])], 
         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])
    grid (lty = 1, col = "white",lwd=2)
  }
  
  if (showID) { #是否显示ID
    text(pca@scores[,xy[1]], pca@scores[,xy[2]], colnames(indata), lwd=1, cex=cex)
  }
  if(showLegend){ #是否绘制图例
    par(xpd = TRUE) #all plotting is clipped to the figure region
    legend(pos1,fill = cols,
           legend=names(table(factor(batch[,batchvar[1]]))),
           inset=c(-batch1move,0), #把分组的图例画到图外
           border = NA,bty = "n")
    legend(pos2,legend=names(table(factor(batch[,batchvar[2]]))),
           border = NA,bty = "n",
           inset=c(-batch2move,0), #把批次的图例画到图外
           pch = (pch.orginal:(pch.orginal-1+N.batch2)))
  }
  invisible(dev.off())
}
```

下面根据场景举两个列子，便于小伙伴儿模仿。

## 场景一，多个批次

### 输入文件

需要两个输入文件：

- easy_input_expr.csv，表达矩阵，包含多个基因在多个样本中的表达量。

- easy_input_batch.csv，样品信息，第一列样品名，跟表达矩阵一致；后面两列是分组（batch1）和批次（batch2）。

```{r}
#表达矩阵
df <- read.csv("easy_input_expr.csv",header = T,row.names = 1,check.names = F, stringsAsFactors = F)
df[1:3,1:3]
#样品信息
batch <- read.csv("easy_input_batch.csv",header = T, row.names = 1, check.names = F,stringsAsFactors = F)
head(batch)

#根据自己的需要决定是否做标准化
#注意scale是对列操作，所以2次转置
indata <- as.data.frame(t(scale(t(df),center = T,scale = T)))
indata[1:3,1:3]
```

### 调用函数画图

```{r}
#自定义颜色
#定义足够多的颜色，用于展示分组
mycol <- c("#223D6C","#D20A13","#088247","#FFD121","#11AA4D","#58CDD9","#7A142C","#5D90BA","#431A3D","#91612D","#6E568C","#E0367A","#D8D155","#64495D","#7CC767")

# 直接出图
pca2batch(indata = indata[,rownames(batch)],
          batch = batch,
          fig.dir = ".", #保存在当前文件夹
          PCA.fig.title = "PCA.2batches",
          cols = mycol[1:length(unique(batch$batch1))],
          showID = F,
          cex = 0.8,
          showLegend = T,
          width=6, height=5, 
          pos1="bottomright", pos2="topright",
          withoutgrid = F) #有网格（例文）

pca2batch(indata = indata[,rownames(batch)],
          batch = batch,
          fig.dir = ".", #保存在当前文件夹
          PCA.fig.title = "PCA.2batches",
          cols = mycol[1:length(unique(batch$batch1))],
          showID = F,
          cex = 0.8,
          showLegend = T,
          width=6, height=5, 
          pos1="bottomright", pos2="topright",
          withoutgrid = T) #无网格（推荐）
```

![](PCA.2batches.withoutgrid.pdf)

![](PCA.2batches.withgrid.pdf)

## 场景二，多次生物学重复

### 输入文件

- GSE125184_CCAB_RPKM_ExpMatrix.csv，基因表达矩阵，行为基因，列为sample。下载自<https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125184>，解压缩，跟FigureYa98STEMheatmap是同一套输入数据。

- easy_input_meta.csv，样品信息，包括分组condition和重复的批次（batch）。

```{r}
## 表达矩阵
expr <- read.csv("GSE125184_CCAB_RPKM_ExpMatrix.csv", check.names = F, row.names = 1)
expr[1:3,1:3]

## 样品信息
metadata <- read.csv("easy_input_meta.csv", header = T, row.names = 1)
head(metadata)
#默认图例会根据分组名字按字母排序
#下面按照自己想要的顺序排序
metadata$condition <- factor(metadata$condition, levels = c("VM", "H", "P1", "P2", "YFB-S", "YFB-C", "YFB-L", "FB-S", "FB-CL"))
```

### 调用函数画图

```{r}
#定义足够多的颜色，用于展示分组
mycol <- c("#223D6C","#D20A13","#088247","#FFD121","#11AA4D","#58CDD9","#7A142C","#5D90BA","#431A3D","#91612D","#6E568C","#E0367A","#D8D155","#64495D","#7CC767")

# 直接出图
pca2batch(indata = expr[,rownames(metadata)], #表达矩阵
          batch = metadata, #样品信息
          pch.orginal = 15, #形状从pch 15正方形开始
          fig.dir = ".", #保存在当前文件夹
          PCA.fig.title = "PCA.replicates", #图题
          cols = mycol[1:length(unique(metadata$condition))], #颜色
          showID = F, #想显示样本名就改为T
          cex = 0.8, #字号
          showLegend = T, #显示图例
          width=6, height=5, 
          batch1move = 0.3, #微调分组图例的位置
          batch2move = 0.36, #微调批次图例的位置
          pos1="topright", pos2="bottomright", #两个图例的位置
          withoutgrid = T) #无网格（推荐）
```

![](PCA.replicates.withoutgrid.pdf)

```{r}
sessionInfo()
```