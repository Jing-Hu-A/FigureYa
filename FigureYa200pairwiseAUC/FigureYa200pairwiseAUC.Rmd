---
title: "FigureYa200pairwiseAUC"
author: "小丫画图出品"
date: "2020-10-16"
output: html_document
---
欢迎关注“小丫画图”公众号，回复“小白”，看小视频，实现点鼠标跑代码。

小丫微信: epigenomics  E-mail: figureya@126.com

作者：大鱼海棠

单位：中国药科大学国家天然药物重点实验室，生物统计与计算药学研究中心

小丫编辑校验

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 需求描述

我想众筹Figure 1B，两个数据集里面看预后判断力都很好的基因。

![](example.png)

出自<https://aasldpubs.onlinelibrary.wiley.com/doi/abs/10.1002/hep.30930>

FIg. 1. PDLIM1 is down-regulated in human metastatic HCC tissues. (A) Heat map showing 402 genes differentially expressed in HCC tissues with or without metastasis based on data set **GSE364**. (B) area under the curve evaluation of the prognostic value of candidate genes involved in metastasis-related events based on data sets **TCGA and GSE10816**. Those genes with no detectable protein expression in liver cancer were excluded and are colored in **gray**.

# 应用场景

训练集定义候选基因，后在两个测试集里寻找预后判断力都好的基因集合。

# 环境设置

使用国内镜像安装包

```{r}
options("repos"= c(CRAN="https://mirrors.tuna.tsinghua.edu.cn/CRAN/"))
options(BioC_mirror="http://mirrors.tuna.tsinghua.edu.cn/bioconductor/")

```

加载包

```{r}
library(limma) # 芯片差异表达
library(impute) # 芯片缺失值多重填补
library(dplyr)
library(pheatmap)
library(gplots)
library(pROC)
library(ggplot2)

Sys.setenv(LANGUAGE = "en") #显示英文报错信息
options(stringsAsFactors = FALSE) #禁止chr转成factor
```

自定义函数

```{r}
# 自定义函数显示进度
display.progress = function ( index, totalN, breakN=20) {
  if ( index %% ceiling(totalN/breakN)  ==0  ) {
    cat(paste(round(index*100/totalN), "% ", sep=""))
  }
} 

# 自定义函数标准化表达谱
standarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  
  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))
  if (!is.null(halfwidth)) {
    outdata[outdata>halfwidth]=halfwidth
    outdata[outdata<(-halfwidth)]= -halfwidth
  }
  return(outdata)
}
```

# 输入文件

需要多套带预后信息的表达数据，分别作为训练集和测试集。

训练集：

- GSE364.expr.txt
- GSE364.sinfo.txt

测试集：

- LIHC.expr.txt (TCGA)，有点大，放到微云上<https://share.weiyun.com/85eUvRBp>
- LIHC.sinfo.txt (TCGA)
- GSE10186.expr.txt
- GSE10186.sinfo.txt

## 加载训练集数据 —— GSE364

```{r}
gse364.expr <- read.table("GSE364.expr.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
gse364.sinfo <- read.table("GSE364.sinfo.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
#gse364.sinfo$prefix <- sapply(strsplit(gse364.sinfo$Title,"-",fixed = T),"[",1)
meta.sam <- rownames(gse364.sinfo[grep("-M[12]$",gse364.sinfo$Title),]) # 
local.sam <- rownames(gse364.sinfo[grep("-P[12]$",gse364.sinfo$Title),]) # 例文只有29个样本
#comid <- intersect(meta.sam$prefix,local.sam$prefix) # 本以为是配对样本但是配对只有20个

gse364.expr <- gse364.expr[,c(meta.sam,local.sam)] %>% as.matrix() %>% impute.knn()
gse364.expr <- log2(gse364.expr$data + 1) %>% as.data.frame()
```

## 加载测试集

```{r}
# TCGA
lihc.expr <- read.table("LIHC.expr.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
lihc.sinfo <- read.table("LIHC.sinfo.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
comsam <- intersect(colnames(lihc.expr), rownames(lihc.sinfo))
lihc.expr <- log2(lihc.expr[,comsam] + 1)
lihc.sinfo <- lihc.sinfo[comsam,,drop = F]

# GSE10186
gse10186.expr <- read.table("GSE10186.expr.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
gse10186.sinfo <- read.table("GSE10186.sinfo.txt",sep = "\t",row.names = 1,check.names = F,stringsAsFactors = F,header = T)
comsam <- intersect(colnames(gse10186.expr), rownames(gse10186.sinfo))
gse10186.expr <- log2(gse10186.expr[,comsam] + 1)
gse10186.sinfo <- gse10186.sinfo[comsam,,drop = F]

# 处理预后信息
lihc.sinfo$fustat <- ifelse(lihc.sinfo$OS == 1 | lihc.sinfo$PFI == 1, 1, 0) # death or progression
```

# 用训练集定义候选基因集

用limma分析差异表达，定义候选基因集，顺便画出图A

```{r}
pd <- data.frame(Samples = c(meta.sam,local.sam),
                 Group = rep(c("meta","local"),c(length(meta.sam),length(local.sam))),
                 row.names = c(meta.sam,local.sam),
                 stringsAsFactors = FALSE)
design <- model.matrix(~ -1 + factor(pd$Group, levels = c("meta","local")))
colnames(design) <- c("meta","local")
fit <- limma::lmFit(as.matrix(gse364.expr), design = design);
contrastsMatrix <- limma::makeContrasts(meta - local, levels = c("meta", "local"))
fit2 <- limma::contrasts.fit(fit, contrasts = contrastsMatrix)
fit2 <- limma::eBayes(fit2, 0.01)
resData <- limma::topTable(fit2, adjust = "fdr", sort.by = "B", number = 100000)
resData <- as.data.frame(subset(resData, select=c("logFC","t","B","P.Value","adj.P.Val")))
resData$id <- rownames(resData)
colnames(resData) <- c("log2fc","t","B","pvalue","padj","id")
resData$fc <- 2^resData$log2fc
resData <- resData[order(resData$padj),]
resData <- resData[,c("id","fc","log2fc","t","B","pvalue","padj")]

# 定义差异表达基因 （原文用log2fc>0.6和p<0.05的阈值我完全找不到差异表达基因，即便用GEO2R网页分析也没有任何满足阈值的基因）
upgene <- rownames(resData[which(resData$log2fc > 0 & resData$pvalue < 0.1),])
dngene <- rownames(resData[which(resData$log2fc < 0 & resData$pvalue < 0.1),])

# 用前面自定义的函数做标准化
plotdata <- standarize.fun(gse364.expr[c(upgene, dngene),],halfwidth = 3)

annCol <- pd
annRow <- data.frame(Dys = rep(c("up","dn"),c(length(upgene),length(dngene))),
                     row.names = c(upgene,dngene),
                     stringsAsFactors = F)
annColors <- list(Group = c("meta"="red","local"="blue"),
                  Dys = c("up"="darkred","dn"="darkblue"))
pheatmap(plotdata,
         cluster_cols = F,
         cluster_rows = F,
         annotation_col = annCol[,"Group",drop = F],
         annotation_row = annRow,
         annotation_colors = annColors,
         show_rownames = F,
         show_colnames = F,
         color = greenred(64),
         border_color = NA)
dev.copy2pdf(file = "heatmap.pdf", width = 5,height = 5)
write.table(annRow,"differential expressed gene.txt",sep = "\t",row.names = T,col.names = NA,quote = F)
```

# 在两个测试集里寻找预后判断力都好的基因集合

```{r}
# 计算auc
comgene <- intersect(intersect(rownames(gse10186.expr),
                               rownames(lihc.expr)),
                     rownames(annRow))
auc1 <- auc2 <- c()
for (i in comgene) {
  # TCGA-LIHC
  tmp <- data.frame(expr = as.numeric(lihc.expr[i,]),
                    fustat = lihc.sinfo$fustat,
                    stringsAsFactors = F)
  auc1 <- c(auc1, roc(predictor = tmp$expr, response = tmp$fustat)$auc)
  
  # GSE10186
  tmp <- data.frame(expr = as.numeric(gse10186.expr[i,]),
                    fustat = gse10186.sinfo$fustat,
                    stringsAsFactors = F)
  auc2 <- c(auc2,roc(predictor = tmp$expr,response = tmp$fustat)$auc)
}
names(auc1) <- names(auc2) <- comgene

# 原文在Human Protemome Project上去找哪些定义的基因是有人类蛋白表达的，这里我就随便取了几个基因，只是为了绘图方便而已。
# 找到满足条件的基因
FAKE.protein.positive <- sample(comgene, size = 0.7 * length(comgene)) #随机取了一些基因作为蛋白表达基因
FAKE.protein.negtive <- setdiff(comgene, FAKE.protein.positive)

auc1.cutoff <- 0.55
auc2.cutoff <- 0.55
finalgene <- intersect(comgene[auc1 > auc1.cutoff & auc2 > auc2.cutoff], FAKE.protein.positive) # 既满足阈值又是蛋白表达的基因
avgauc <- c(auc1[finalgene] + auc2[finalgene])/2
pickgene <- "B4GALNT1" # 因为和原文结果不同所以随便选的
```

# 开始画图

用base plot画图，从plot开始整段运行。

```{r}
xrange <- pretty(range(auc1))
yrange <- pretty(range(auc2))

par(mfrow = c(1,2)) # 把画布分成左右两个
par(bty="l", mgp = c(2.4,.33,0), mar=c(4.1,4.6,2.1,2.1)+.1, las=1, tcl=-.25)

# 绘制“假的”有蛋白表达的散点
plot(x = auc1[FAKE.protein.positive],
     y = auc2[FAKE.protein.positive],
     xlab = "AUC for disease event\ninTCGA-LIHC",
     ylab = "AUC for disease event\nin GSE10186",
     pch = 19,
     col = "#5D7ABE",
     cex = 1.2,
     xlim = c(xrange[1],xrange[length(xrange)]),
     ylim = c(yrange[1],yrange[length(yrange)]),
     xaxt = "n",
     yaxt = "n")
# 添加“假的”无蛋白表达的散点
points(x = auc1[FAKE.protein.negtive],
       y = auc2[FAKE.protein.negtive],
       pch = 19,
       cex = 1.2,
       col = ggplot2::alpha("grey70", 0.8))
# 添加“假的”有蛋白表达且AUC满足阈值且感兴趣的目标基因
points(x = auc1[pickgene],
       y = auc2[pickgene],
       pch = 19,
       cex = 1.2,
       col = ggplot2::alpha("red", 0.8))
axis(side = 1,at = xrange)
axis(side = 2,at = yrange)
# 添加阈值区域框
rect(xleft = auc1.cutoff,xright = max(auc1) + 0.01,
     ybottom = auc2.cutoff,ytop = max(auc2) + 0.01,
     lwd = 1.5,
     lty = 2)

# 右侧绘制AUC均值
par(bty="l", mgp = c(1.9,.33,0), mar=c(4.1,5.1,2.1,2.1)+.1, las=1, tcl=-.25)
a <- barplot(sort(avgauc,decreasing = F),
        horiz = T,
        col = ifelse(names(sort(avgauc,decreasing = F)) == pickgene,"red","#5D7ABE"),
        xlab = "Mean AUC")
axis(side = 2,at = a,labels = F)
dev.copy2pdf(file = "combined pairwise auc.pdf", width = 9, height = 5)
```

# Session Info

```{r}
sessionInfo()
```